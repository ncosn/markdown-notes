# 2023/7/3-7/6

## 安卓

#### RxJava+Retrofit

把原来的Call改为Observable

```java
// subscribeOn在io线程执行
// observeOn切换回主线程
// subscribe订阅
httpbinService.test3("client_credentials",API_KEY,SECRET_KEY)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(new Consumer<String>() {
    @Override
    public void accept(String s) throws Exception {
        JsonObject returnData = new JsonParser().parse(s).getAsJsonObject();
        Log.i("TAG", "accept: " + returnData.get("access_token"));
    }
}, new Consumer<Throwable>() {
    @Override
    public void accept(Throwable throwable) throws Exception {

    }
});
```

```java
// .addCallAdapterFactory适配转换，原本拿到的是Call<String>，使用rxjava的calladapter转换成Observable<String>。
retrofit = new Retrofit.Builder()
        .baseUrl("https://aip.baidubce.com/oauth/2.0/")
        .client(client)
        .addConverterFactory(ScalarsConverterFactory.create())
        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
        .build();
```





#### OkHttpClient.Builder()

在 OkHttp 中，`OkHttpClient.Builder()` 是用于构建 `OkHttpClient` 实例的建造者模式。其中的 `cookieJar()` 方法是用于设置处理 cookie 的策略。

Cookie 是一种服务器在客户端存储数据并在每次请求中将其发送回服务器的机制，用于在不同的请求之间保持状态。`cookieJar()` 方法允许你配置 OkHttp 客户端使用自定义的 `CookieJar` 实现来处理 cookie。

`cookieJar()` 方法接受一个 `CookieJar` 实例作为参数，用于设置用于处理 cookie 的策略。你可以使用 OkHttp 提供的 `CookieJar` 实现，也可以自定义实现。



#### Retrofit.Builder().addConverterFactory()

在 Retrofit 中，`Retrofit.Builder()` 是用于创建 `Retrofit` 实例的建造者模式。其中的 `addConverterFactory()` 方法用于添加请求和响应的转换器工厂。

转换器工厂是一种将请求和响应中的数据进行转换的组件。`addConverterFactory()` 方法允许你添加自定义的转换器工厂，用于将请求和响应的数据转换为所需的类型，例如将 JSON 数据转换为 Java 对象。

Retrofit 提供了多个内置的转换器工厂，包括 `GsonConverterFactory`、`MoshiConverterFactory`、`JacksonConverterFactory` 等，它们用于处理各种不同类型的数据。



### RxJava（Android进阶之光）

观察者：Observer观察事件变化并处理的主要角色。消费者Consumer可以理解为特殊的观察者。

被观察者：触发事件并决定什么时候发送事件的主要角色。

订阅：观察者和被观察者建立关联的操作。



subscribe()中通常使用Consumer，因为Observer要重写四个方法

Consumer抛出异常采用new Consumer\<Throwable>(){}，简化了异常的处理

subscribe中发送消息，观察者中接收

```java
Observable observable = Observable.create(new Observable.OnSubscribe<String>() {
    @Override
    public void call(Subscribe<? super String> subscriber) {
        // 事件产生的地方
    }
});
```

```java
/**
 * Observer，重写四个方法
 *
 */
Observable.create(new ObservableOnSubscribe<Object>() {
    @Override
    public void subscribe(ObservableEmitter<Object> emitter) throws Exception {
        // 发送事件，事件产生的地方
        emitter.onNext("1");
    }
}).subscribe(new Observer<Object>() {
    @Override
    public void onSubscribe(Disposable d) {
        // 建立订阅后立即执行的回调方法
        // 在此处进行订阅时的操作，例如显示进度条
    }
    @Override
    public void onNext(Object o) {
        
    }
    @Override
    public void onError(Throwable e) {
        
    }
    @Override
    public void onComplete() {
        
    }
    
})
```

```java
/**
 * Consumer，只重写accept方法。处理发送的事件（onNext）或者处理异常。
 *
 */
Observable.create(new ObservableOnSubscribe<Object>() {
    @Override
    public void subscribe(ObservableEmitter<Object> emitter) throws Exception {
        // 发射事件，事件产生的地方
        // emitter.onNext("1");
        
        // 耗时操作
        // 网络请求
        // 异步操作放在这里
    }
}).subscribe(new Consumer<Object>() {
    @Override
    public void accept(Object) throws Exception {
    }
}, new Consumer<Throwable>() {
    @Override
    public void accept(Throwable throwable) throws Exception {
    }
})
```



#### 创建操作符

create()——创建Observable

just()——快速创建被观察者（最多十个，重载了十个fromArray）

```java
Observable.just("1","AAA","2").subscribe(observer);
// 相当于创建Observable并传入三个事件
// 对应subscribe()方法中emitter.onNext("1");emitter.onNext("AAA");emitter.onNext("2");
    
```

fromArray（个数无限制）

fromIterable

```java
ArrayList<String> list = new ArrayList<>();
list.add("111");
list.add("222");
Observable.fromArray(list).subscribe(observer);
```

fromFuture

fromCallable



interval——每隔一段时间会发送一个事件，这个事件是从0开始的，不断增1的数字。如创建固定时间间隔发送整数序列的Observable，相当于定时器。

range——同时发送一定范围的时间序列。如创建发射指定范围的整数序列的Observable，可以拿来替代for循环。

repeat——如创建一个N次重复发射特定数据的Observable。



#### 转换操作符

map()——直接对发射出来的事件进行处理并且产生新的事件，再次创建被观察者，发射事件

> Function<T,U>——T类型转换为U类型

```java
// map处理的是事件，在apply方法中处理"aaa"，并返回"BBB"，可以改变被观察者发送的数据类型
Observable observable = Observable.just("aaa")
    .map(new Function<String, Object>() {
        @Override
        public Object apply(String s) throws Exception {
            return "BBB";
        }
    }).subscribe(observable)
```

flatmap()

```java
// 网络请求场景当中常用的操作符
// 可以将事件序列中的元素进行整合加工，返回一个新的被观察者
Observable observable = Observable.just("register")
    .flatmap(new Function<String, ObservableSource<?>>() {
        @Override
        public ObservableSource<?> apply(String s) throws Exception {
            System.out.println(s + "成功");
            return Observable.just("请求登录");
        }
    }).subscribe(observable)
```

concatmap()

```java
// 和flatMap()基本上一样，concatMap()转发出来的事件是有序的，而flatMap()是无序的（通常也是有序的）
```

buffer()

```java
// 从需要发送的事件当中获取一定数量的时间，并将这些事件房嫂缓冲区当中一并发出
Observable.just("111","222","333","444","555","666","777","888","999","AAAAA")
    .buffer(3)
    .subscribe(observer);

// 输出
// onNext···[111,222,333]
// onNext···[444,555,666]
// onNext···[777,888,999]
// onNext···[AAAAA]
```



#### 组合操作符

concat()

```java
// Observable的静态方法
// 将多个 Obserbavle 发射的数据进行合并发射。concat 严格按照顺序发射数据，前一个Observable没发射 完成是不会发射后一个Observable的数据的。
Observable.concat(Observable.just("1111"),
                 Observable.just("222"))
    			  .subscribe(observer);

// 输出
// 只订阅一次，所有被观察者打包到一个新的被观察者
onSubscribe...
onNext...1111
onNext...222
onComplete...
```

concatArray()——（同concat，没有个数限制）



#### 功能操作符

subscribeOn()——用于指定Observable自身在哪个线程上运行（执行subscribe方法所处的线程）。如果Observable需要执行耗时操作，一 般可以让其在新开的一个子线程上运行。

> 注：多次调用只有第一次有效

observerOn()——用来指定Observer所运行的线程，也就是发射出的数据 在哪个线程上使用。一般情况下会指定在主线程中运行，这样就可以修改UI。

> 注：影响下游事件被处理所处的线程

```java
// 不做线程切换，事件发射和处理默认则在主线程中执行，线程切换后只有subscribe在主线程
// 

Observable.create(new ObservableOnSubscribe<Object>() {
    @Override
    public void subscribe(ObservableEmitter<Object> emitter) throws Exception {
        // 创建事件 发射事件
        
        // 模拟网络请求
        Thread.sleep(2000);
        emitter.onNext("aaa");
        emitter.onNext("bbb");
        emitter.onComplete();
    }
}).subscribeOn(Schedulers.newThread())
    .subscribe(new Observer<Object>() {
    @Override
    public void onSubscribe(Disposable d) {
        // 建立订阅后立即执行的方法
        // 在此处进行订阅时的操作，例如显示进度条
    }
    @Override
    public void onNext(Object o) {
        
    }
    @Override
    public void onError(Throwable e) {
        
    }
    @Override
    public void onComplete() {
        
    }
    
})
```

doOnNext()——在调用onNext之前调用



#### 过滤操作符

filter()

```java
// 过滤
Observable.range(1,10)
    .filter(new Predicate<Integer>() {
        @Override
        public boolean test(Integer integer) throws Exception {
            return integer<5;
        }
    })
    .subscribe(observer);
    
```





#### map&flatmap详解

```java
Observable.fromIterable(StudentModel.getStudent())
    .map(NEW )
```



#### RxJava观察者模式

<img src="每日笔记/image-20230707105110895.png" alt="image-20230707105110895" style="zoom: 67%;" />



> ObservableSource是顶层接口类，有一个subscribe(Observer)方法
>
> Observable抽象类实现ObservableSource，实现subscribe方法，提供抽象方法subscribeActual(Observer)
>
> (create操作符的具体实现)ObservableCreate类泛化（继承）Observable类，实现subscribeActual()方法，依赖于Observer类；关联了ObservableOnSubscribe类，定义source变量；
>
> ObservableOnSubscribe类有一个subscribe(Emitter)方法，依赖于Emitter类
>
> Emitter接口有三个方法onNext，onComplete，onError
>
> CreatEmitter类关联了Observer类；泛化（继承）Emitter接口，实现了Emitter三个方法
>
> Observer类有四个方法
>
> 

[手写observable](https://www.bilibili.com/video/BV1H54y1j7uN?p=23&spm_id_from=pageDriver&vd_source=bf286743c0f79ff4e4df2222645065d3)



#### RxJava装饰器模式

<img src="每日笔记/image-20230710163743051.png" alt="image-20230710163743051" style="zoom:67%;" />

不改变现有对象结构的情况下，动态地给对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式

减少类继承层次

> AbstractObservableWithUpStream 抽象装饰类，拥有一个顶层接口的实例ObservableSource source
>
> ObservableMap 继承抽象装饰类，实现了一个Function function（构造方法中传入），内部类MapObserver
>
> Function 转换类型的接口，有一个apply方法
>
> MapObserver 实现了Observer，创建了





### Retrofit

网络请求时会进行响应数据和对象（如ResponseData）的转换

```java
.addConverterFactory(···)//添加转换方法
```



### Okhttp

#### RequestBody

在网络编程中，`RequestBody` 是用于封装请求主体数据的类。它用于将数据作为请求的主体内容发送到服务器。在不同的网络库或编程语言中，`RequestBody` 可以有不同的实现和使用方式。下面是一些常见的 `RequestBody` 类型：

1. `RequestBody.create(MediaType, String)`：通过指定媒体类型（`MediaType`）和字符串创建请求体。
2. `RequestBody.create(MediaType, byte[])`：通过指定媒体类型（`MediaType`）和字节数组创建请求体。
3. `FormBody`：用于创建表单编码的请求体，其中包含键值对形式的数据。常见于 `application/x-www-form-urlencoded` 类型的表单请求。
4. `MultipartBody`：用于创建多部分请求体，用于上传文件或包含二进制数据的请求。可以包含多个部分（`Part`），每个部分可以具有不同的媒体类型和内容。
5. `TypedInput`：在某些网络库中，用于封装请求体数据的接口，允许以更灵活的方式处理不同类型的内容。



#### 异步上传文件

```java
//定义上传文件类型
public static final MediaType MeEDIA_TYPE_MARKDOWN 
    = MediaType.parse("text/x-markdown; charset=utf-8");
```

```java
//在SD卡根目录创建一个wangshu.txt文件，里面的内容为"OKHttp"
String filepath = "";
if (Environment.getExternalStoragrState()
    .equals(Environment.MEDIA_MOUNTED)) {
    filepath = Environment.getExternalStorageDirectory().getAbsolutePath();
} else {
    return;
}
File file = new File(filepath,"wangshu.txt");
Request request = new Request.Builder()
    .url("https://api/github.com/markdown/raw")
    .post(RequestBody.create(MEDIA_TYPE_MARKDOWN,file))
    .build();
mOkHttpClient.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
    }
    @Override
    public void onResponse(Call call, Response response) throws IOException {
        Log.d(TAG,response.body().string());
    }
});
```

#### 异步下载文件

```java
//下载一张图片，得到Response后将流写进我们指定的图片文件中，代码如下所示
String url = "http://img.my.csdn.net/uploads/201603/26/1458988468_5804.jpg";
Request request = new Request.Builder().url(url).build();
mOkHttpClient.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call,IOException e) {
    }
    @Override
    public void onResponse(Call call,Response response) {
        InputStream inputStream = response.body().byteStream(); // 获取输入流
        FileOutputStream fileOutputStream = null;
        String filepath = "";
        try {
            if (Environment.getExternalStorage()
                .equals(Environment.MEDIA_MOUNTED)) {
                // 外部存储目录的绝对路径
                filepath = Environment.getExternalStorageDirectory().getAbsolutePath();
            } else {
                // 内部存储目录的绝对路径，通常是 /data/data/<package_name>/files
                filepath = getFileDir().getAbsolutePath();
            }
            File file = new File(filepath,"wangshu.jpg");
            if (null != file) {
                fileOutputStream = new FileOutputStream(file);
                byte[] buffer = new byte[2048]; // 创建缓冲区
                int len = 0; // 用于存储已读取的字节数
                // 用于从输入流（InputStream）中读取数据并存储到缓冲区（buffer）中
                while ((len = inputStream.read(buffer)) != -1) {
                    fileOutputStream.write(buffer, 0, len);
                }
                fileOutputStream.flush();
            } catch (IOException e) {
                Log.d(TAG,"IOException");
                e.printStackTrace();
            }
        }
    }
});
```



#### 异步上传Multipart文件

```java
//有时上传文件，同时还需要传其他类型的字段。OkHttp 3实现起来很简单。需要注意的是没有服务器接收我这个Multipart文件，所以这里只是举个例子，具体的应用还要结合实际工作中对应的服务器。
private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
private void sendMultipart() {
    mOkHttpClient = new OkHttpClient();
    RequestBody requestBody = new MultipartBody.Builder()
        .setType(MultipartBody.FORM)
        .addFormDataPart("title","wangshu")
        .addFormDataPart("image","wangshu.jpg",
                        RequestBody.create(MEDIA_TYPE_PNG,new File("/sdcard/wangshu.jpg")))
        .build();
    
    Request request = new Request.Builder()
        .header("Authorization","Client-ID"+"...")
        .url("https://api.img.com/3/image")
        .post(requestBody);
    
    mOkHttpClient.newCall(request).enqueue(new Callback() {
        @Override
        public void onFailure(Call call, IOException e) {
        }
        @Override
        public void onResponse(Call call,Response response) throws IOException {
            Log.d(TAG, response.body().string());
        }
    });
}

```



#### 设置超时时间和缓存

```java
File sdcache = getExternalCacheDir();
int cacheSize = 10 * 1024 * 1024;
OkHttopClient.Builder builder = new OkHttpClient,Builder()
    .connectTimeout(15, TimeUnit.SECONDS)
    .writeTimeout(20, TimeUnit.SECONDS)
    .readTimeout(20, TimeUnit.SECONDS)
    .cache(new Cache(sdcache.getAbsoluteFile(),cacheSize));
mOkHttpClient = builder.build();
```



#### 取消请求

使用call.cancel()可以立即停止一个正在执行的call。当用户离开一个应用时，或者跳到其他界面时，使用call.cancel()可以节约网络资源；不管同步还是异步的call都可以取消，也可以通过tag来同时取消多个请求。当构建一个请求时，使用Request.Builder.tag(Object tag)来分配一个标签，之后可以使用OkHttoClient.cancel(Object tag)来取消所有带有这个tag的call。

```java
private ScheduleExecuteorService executor = Executors.newScheduledThreadPool(1);
private void cancel() {
    final Request request = new Request.Builder()
        .url("https://www.baidu.com")
        .cacheControl(CacheControl.FORCE_NETWORK)//1
        .build();
    Call call = null;
    call = mOkHttpClient.newCall(request);
    final Call finalCall = call;
    // 100ms后取消call
    executor.schedule(new Runnable() {
        @Override
        public void run() {
            finalCall.cancel();
        }
    },100,TimeUnit.MILLISECONDS);
    call.enqeue(new Callback() {
        @Override
        public void onFailure(Call call, IOException e) {
        }
        @Override
        public void onResponse(Call call,Response response) throws IOException {
            if (null != response.cacheResponse()) {
                String str = reponse,cacheResponse().toString();
                Log.d(TAG, "cache---"+str);
            } else {
                String str = response.networkResponse().toString();
                Log.d(TAG, "network---"+str);
            }
        }
    });
}
```

创建定时线程池，100 ms后调用call.cancel（）来取消请求。为了能让请求耗时，在上面代码注释1处设 置每次请求都要请求网络，运行程序并且不断地调用cancel方法。Log打印结果如图5-13所示。

很明显每次cancel（）都失败了，也就是仍旧成功地访问了网络。每隔100 ms来调用call.cancel（）显然 时间间隔太长，我们设置为1 ms，再运行程序并且不断地调用cancel方法，这时就会发现没有Log打印出 来，那是因为每个请求都被取消了。





## GPT

Q：使用rxjava和retrofit进行网络访问，网络访问是在什么时候进行

> A：当你创建一个Retrofit的Service接口并定义了网络请求方法时，这些方法只是描述了网络请求的行为，而不会立即执行。当你在代码中调用`subscribe()`方法订阅这些网络请求的Observable时，才会触发执行网络请求。
>
> 在 `onNext()` 方法中，你可以处理网络请求成功的结果，并将响应数据发送给订阅者。



Q：Environment.getExternalStoragrState()方法的返回值

> A：`Environment.getExternalStorageState()` 是一个方法用于获取外部存储（例如SD卡）的状态。它会返回一个表示外部存储状态的字符串。
>
> 以下是可能的返回值及其含义：
>
> - `Environment.MEDIA_UNKNOWN`：外部存储状态未知。
> - `Environment.MEDIA_REMOVED`：外部存储未插入或已被移除。
> - `Environment.MEDIA_UNMOUNTED`：外部存储已插入，但未被挂载。
> - `Environment.MEDIA_CHECKING`：正在检查外部存储的状态。
> - `Environment.MEDIA_NOFS`：外部存储上没有文件系统。
> - `Environment.MEDIA_MOUNTED`：外部存储已插入且已被挂载，可读写。
> - `Environment.MEDIA_MOUNTED_READ_ONLY`：外部存储已插入且已被挂载为只读。
>
> 需要注意的是，在 Android 10（API级别29）及更高版本中，对外部存储的访问权限发生了变化，因此 `getExternalStorageState()` 返回的值可能与之前的版本有所不同，具体取决于应用的访问权限和设备的配置。
>
> 为了确保正确的外部存储状态，请确保在调用 `getExternalStorageState()` 之前已经获取了外部存储的读写权限，并且考虑处理各种返回值以适应不同的状态情况





# 2023/7/5

## 安卓



[android studio运行main](https://blog.csdn.net/m0_37849939/article/details/124979656)

在Project模式下：.idea下找到文件[gradle](https://so.csdn.net/so/search?q=gradle&spm=1001.2101.3001.7020).xml，在里面加入：`<option name="delegatedBuild" value="false" />`



## GPT

Q：类加载机制如何避免多线程问题？

> A：类加载机制本身并没有直接避免多线程问题的能力，但可以通过一些机制来减少多线程问题的发生。下面介绍两种常用的类加载机制来处理多线程问题：
>
> 1.**加锁机制**：通过在类加载过程中使用锁来确保只有一个线程可以进行类加载操作。Java中的类加载器在加载类时会使用锁来保证线程安全。每个类加载器都有一个与之关联的锁，当某个类加载器开始加载类时，会尝试获取该锁。如果其他线程已经占用了锁，那么当前线程将等待，直到锁释放后再重新尝试获取。这样可以确保在任何时刻只有一个线程在加载某个类，从而避免了多线程竞争的问题。
> 2.类加载的原子性：类加载过程具有原子性，即整个类加载过程中的各个步骤是不可分割的，要么全部完成，要么全部失败。这种原子性可以避免多线程环境下的竞争问题。当多个线程同时尝试加载同一个类时，只有一个线程可以成功加载，其他线程会因为获取不到锁而等待或者抛出异常。这确保了每个类只会被加载一次，避免了多个线程同时加载同一个类的问题。
>
> 需要注意的是，尽管类加载机制可以在一定程度上避免多线程问题，但并不能完全解决所有的多线程并发访问问题。其他代码中的同步机制、并发控制等技术仍然是处理多线程问题的主要手段。在编写多线程代码时，仍然需要小心处理同步和线程安全等问题，以保证代码的正确性和稳定性。



Q：类加载和类初始化是一个概念吗？

> A：不，类加载和类初始化是两个不同的概念。
> 类加载（Class Loading）是指将类的字节码文件加载到内存，并在内存中创建一个代表该类的Class对象的过程。类加载是Java虚拟机的核心功能之一，负责将编译后的字节码文件加载到内存中，并进行诸如验证、准备（为静态变量分配内存并设置默认值）、解析（将符号引用转换为直接引用）等操作。类加载的目的是为了在程序运行时使用这些类。
> 类初始化（Class Initialization）是类加载的最后阶段，负责对类进行初始化。类初始化是类加载过程的一部分，它主要执行静态变量的赋值和静态代码块的执行以及执行静态方法。类初始化在类第一次被使用时触发，例如创建实例对象、访问静态变量、调用静态方法等。
> 类加载和类初始化虽然相关，但并不是完全相同的概念。**类加载是将类的字节码加载到内存中的过程，而类初始化是类加载的最后阶段，用于执行类的初始化操作。**注意，类可以被加载但尚未进行初始化，只有在需要时，才会立即初始化类。



​	Q：rxjava中diposable用法？

> A：在 RxJava 中，Disposable 是一个用于表示可取消订阅的接口。它提供了一种机制，允许您在不再需要执行操作时取消订阅 Observable 或 Flowable。通过 Disposable，您可以手动取消订阅以释放资源、停止操作或避免内存泄漏。
> 使用 Disposable 主要涉及以下几个方面：
>
> 1.创建 Disposable：
>
> + 通过调用 subscribe() 方法返回的 Disposable 对象，您可以获取到订阅的引用。例如：
>
>  ```java
>  Disposable disposable = Observable.just("Hello, RxJava!")
>      .subscribe(value -&gt; System.out.println(value));
>  ```
>
> 
>
> 2.取消订阅：
>
> + 调用 dispose() 方法可以手动取消订阅并释放相关资源。例如：
>
>  ```java
>  disposable.dispose();
>  ```
>
> 
>
> 3.检查订阅状态：
>
> + 您可以使用 isDisposed() 方法检查 Disposable 的订阅状态，以判断是否已经取消订阅。例如：
>
> ``` java
>  if (disposable.isDisposed()) {
>      // 已取消订阅
>  } else {
>      // 仍在订阅中
>  }
> ```
>
> 
>
> 4.自动取消订阅：
>
> + 在某些情况下，例如使用 CompositeDisposable 进行多个订阅管理时，可以通过将 Disposable 添加到 CompositeDisposable 中来实现自动取消订阅。当 CompositeDisposable 被清理时，它会自动取消包含的所有订阅。例如：
>
>  ```java
>  CompositeDisposable compositeDisposable = new CompositeDisposable();
>  Disposable disposable1 = ...
>  Disposable disposable2 = ...
>  // 将 Disposable 添加到 CompositeDisposable
>  compositeDisposable.add(disposable1);
>  compositeDisposable.add(disposable2);
>  // 清理 CompositeDisposable 时，会自动取消订阅所有 Disposable
>  compositeDisposable.clear();
>  ```
>
> 
>
> 5.控制订阅生命周期：
>
> + 使用 Disposable，您可以控制订阅的生命周期，手动取消订阅以适应不同的场景，避免资源浪费和潜在的内存泄漏。当不需要订阅时，应主动取消订阅以确保资源释放。
>
> 请注意，RxJava 还提供了各种操作符和组合器，可以进一步处理和管理订阅的生命周期。通过正确使用 Disposable，您可以优雅地管理异步流操作，确保资源的正确释放和应用程序的可靠运行。



Q：CompositeDisposable用法

> CompositeDisposable 是 RxJava 中提供的一个 Disposable 容器，用于管理多个 Disposable 对象，并在需要时进行集中处理和取消订阅。它可以方便地管理和控制多个订阅的生命周期。
> 使用 CompositeDisposable 的常见用法如下：
>
> 1.创建 CompositeDisposable 对象：
>
> ```java
> CompositeDisposable compositeDisposable = new CompositeDisposable();
> ```
>
>
> 2.将 Disposable 对象添加到 CompositeDisposable：
>
>    ```java
>    Disposable disposable1 = observable1.subscribe();
>    Disposable disposable2 = observable2.subscribe();
>    compositeDisposable.add(disposable1);
>    compositeDisposable.add(disposable2);
>    ```
>
> 3.执行操作和观察结果：
>
>    // 执行操作，观察结果
>
>
> 4.取消订阅：
>
>  ```java
>  compositeDisposable.dispose();
>  ```
>
> 这将自动取消 CompositeDisposable 中包含的所有 Disposable 对象的订阅。
> 您也可以使用 remove() 方法从 CompositeDisposable 中移除单个 Disposable：
> compositeDisposable.remove(disposable);
>
> 这样可以选择性地取消订阅某个 Disposable，而不是一次性取消所有订阅。
> 通过使用 CompositeDisposable，您可以更方便地管理多个 Disposable 对象的订阅和取消订阅。它特别适用于需要批量处理和取消多个订阅的场景，例如在 Activity 或 Fragment 销毁时取消所有订阅。
>
> ```java
> public class MyActivity extends AppCompatActivity {
>     private CompositeDisposable compositeDisposable = new CompositeDisposable();
>     @Override
>     protected void onCreate(Bundle savedInstanceState) {
>         super.onCreate(savedInstanceState);
>         setContentView(R.layout.activity_main);
> 
>         // 创建 Disposable
>         Disposable disposable1 = ...
>     	Disposable disposable2 = ...
> 
>         // 将 Disposable 添加到 CompositeDisposable
>         compositeDisposable.add(disposable1);
>     	compositeDisposable.add(disposable2);
>     }
> 
>     @Override
>     protected void onDestroy() {
>         super.onDestroy();
>         // 在 Activity 销毁时取消所有订阅
>         compositeDisposable.dispose();
>     }
> }
> ```
> 这样，在 Activity 销毁时，CompositeDisposable 会自动取消所有订阅，避免潜在的内存泄漏和无效的操作。
> 总之，CompositeDisposable 提供了一种简单而强大的方式来管理多个 Disposable 对象的订阅和取消订阅。它可以帮助您有效地处理复杂的异步操作和资源释放，确保您的 RxJava 代码具有良好的可维护性和可靠性。





# 2023/7/7

## Java

### [UML图](https://www.cnblogs.com/zrecord/p/15146543.html)

#### 实现Realize

关系：用来表示类与接口、抽象类与接口之间的关系

箭头：空心三角形+虚线，箭头指向接口

#### 泛化Generalize

关系：是一种继承关系，用来表示类与类、类与抽象类、抽象类与抽象类、接口与接口之间的关系

箭头：空心三角+实现，箭头指向父类或父接口

#### 关联Associate

关系：是一种拥有关系，关联可以是双向的；关联关系可以进一步划分为聚合及组合关系

箭头：用实线箭头表示，双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头

比如：人和车

#### 聚合Aggregate

关系：表示整体与部分的关系，且部分可以离开整体而单独存在。是一种较强的关联关系

箭头：用空心的菱形+实线箭头表示，菱形指向整体

比如：电脑和键盘

#### 组合Composition

关系：是一种整体与部分的关系，但部分不能离开整体而单独存在。是一种强的关联关系

箭头：用实心的菱形+实线箭头表示，菱形指向整体

#### 依赖Dependency

关系：是一种使用关系，即一个类的实现需要另一个类的协助。

箭线：用虚线箭头表示，箭头指向被依赖的对象。



## GPT

在RxJava中，Observable对象和Subscriber对象之间可以通过方法链进行连接和配置。

在这里，我们可以看到以下方法链的用法：

1. `Observable.create(...)` 创建了一个Observable对象，并定义了`subscribe(...)`方法中的事件发射逻辑。这个`create(...)`方法返回的Observable对象被用作方法链的起点。
2. `.subscribeOn(Schedulers.newThread())` 方法链将Observable对象的执行线程指定为新的线程。这表示Observable的事件发射和处理将在新的线程中执行。
3. `.observeOn(AndroidSchedulers.mainThread())` 方法链指定Observer（Subscriber）对象的回调方法应该在Android主线程上执行。这样做是为了确保UI操作在主线程上执行，避免在子线程操作UI带来的问题。
4. `.subscribe(...)` 方法链将Observer对象订阅到Observable对象上。在这里，我们通过实现Observer接口的匿名内部类来定义相关的回调方法，包括`onSubscribe(...)`, `onNext(...)`, `onError(...)`, `onComplete(...)`。

通过这种方法链的方式，我们可以将多个操作以连贯的方式组装在一起，实现复杂的异步处理逻辑。每个方法调用都返回调用该方法的对象本身，使得我们能够在后续方法上继续链式调用。



Q：但是为什么他们的返回值不是this？

> A：对于RxJava中的方法链，每个方法通常返回一个新的对象，而不是返回调用该方法的对象本身（即this）。
>
> 这是因为RxJava的设计目标是实现响应式编程，允许通过方法链来组装和配置异步操作的各个环节，而不是在原始对象上修改状态。
>
> 方法链中的每个方法都会创建一个新的对象，该对象封装了前一个对象的状态和配置，并根据方法的调用进行相应的操作。这种设计带来了许多的优点，包括：
>
> 1. 链式调用的可读性：每个方法都是对前一个对象的操作，并且可以根据需求自由组合和排序方法调用，使得代码更加清晰易读。
> 2. 不可变性：由于每个方法创建了一个新的对象，原始对象的状态是不可变的。这对于多线程和并发操作是非常重要的，可以避免潜在的竞态条件和线程安全问题。
> 3. 灵活的组合和重用：通过方法链，可以方便地组合和重用不同的操作，根据需要创建出更复杂的异步处理逻辑。
>
> 因此在RxJava中，方法链通常返回一个新的对象，以便保持不可变性和灵活性，同时实现可读性和可维护性



# 2023/7/10-12

## 安卓

### RxJava补充

### <img src="每日笔记/image-20230710163535903.png" alt="image-20230710163535903" style="zoom:67%;" />

Observable.create(···).map(···).subscribe(···)

create中返回一个被观察者ObservableCreate

map中产生一个观察者MapObserver并订阅ObservableCreate，返回一个被观察者ObservableMap

subscribe中observer订阅ObservableMap



#### **防止内存泄漏，取消订阅**(compose、RxLifecycle)

+ 在onDestroy中disposable.dispose()

  > Observable.subscribe（Consumer）——返回值 Disposable

+ 在Application中，捕获异常
  ```java
  // 取消订阅后，抛出的异常无法捕获，导致程序崩溃
  RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
      @Override
      public void accept(Throwable throwable) throws Exception {
          Log.i("TAG","setErrorHanlder accept:throwable="+throwable.toString());
      }
  });
  ```

多个disposable使用compositeDisposable统一取消

```java
CompositeDisposable compositeDisposable;
compositeDisposable.add(disposable);

// onDestroy()
compositeDisposable.dispose();
```



**compose()**

使用compose()代替subscribeOn和observeOn，代码复用

```java
public class SchedulerTransformer<T> implements ObservableTransformer<T,T> {
    @Override
    public ObservableSource<T> apply(Observable<T> upstream) {
        return upstream.subscribe(Schedulers.io())
            .observeOn(AndroidSchedulers.mainThread());
    }
}

// 使用compose
.compose(new SchedulerTransformer<>())
```



**优化**

RxLifecyle rxLiftcycle = new RxLifecycle();

 ```java
 // RxLifecycle.class
 public class RxLifecycle<T> implements LifecycleObserver, ObservableTransformer<T,T> {
 
     final CompositeDisposable compositeDisposable = new CompositeDisposable();
 
     @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
     void onDestory() {
         Log.i("TAG", "onDestory: ");
         if (!compositeDisposable.isDisposed()) {
             compositeDisposable.dispose();
         }
     }
 
 
     @Override
     public ObservableSource<T> apply(Observable<T> upstream) {
         // 调用 subscribe 方法时，会触发订阅操作，然后 doOnSubscribe 方法就会被执行
         return upstream.doOnSubscribe(new Consumer<Disposable>() {
             @Override
             public void accept(Disposable disposable) throws Exception {
                 compositeDisposable.add(disposable);
             }
         });
     }
 
     public static <T> RxLifecycle<T> bindRxLifecycle(LifecycleOwner lifecycleOwner) {
         RxLifecycle<T> lifecycle = new RxLifecycle();
         lifecycleOwner.getLifecycle().addObserver(lifecycle);
         return lifecycle;
     }
 }
 ```

```java
// SecondActivity.class
RxLifecycle rxLifecycle = new RxLifecycle();
getLifecycle().addObserver(rxLifecycle);

Observable.create(new ObservableOnSubscribe<Object>() {
    @Override
    public void subscribe(ObservableEmitter<Object> emitter) throws Exception {
        Log.i("TAG", "subscribe: 开始请求数据");
        Thread.sleep(5000);
        Log.i("TAG", "subscribe: 数据请求结束");
        emitter.onNext("Success");
        emitter.onComplete();
    }
}).compose(new SchedulerTransformer<>())
    .compose(RxLifecycle.bindRxLifecycle(this))
    .subscribe(new Consumer<Object>() {
        @Override
        public void accept(Object o) throws Exception {
            Log.i("TAG", "accept: " + o);
        }
    });
```



#### Subject

同时代表一个观察者和被观察者，允许将事件从单个源多播到多个子观察者

RxJava提供四种Subject：

+ AsyncSubject：无论发送多少条数据，无论在订阅前发射还是订阅后发射，都只会受到最后一条发射的数据。
+ BehaviorSubject：只会接收到订阅前最后一条发送的数据以及订阅之后所有的数据。
+ ReplaySubject：会接收到全部数据，无论订阅前后。
+ PublishSubject：只会接受到订阅之后的所有数据。

```java
AsyncSubject<Object> objectAsyncSubject = AsyncSubject.create();
objectAsyncSubject.onNext("A");
objectAsyncSubject.onNext("B");
objectAsyncSubject.subscribe(new Consumer<Object>() {
    @Override
    public void accept(Object o) throws Exception {
        System.out.println("accept:"+o);
    }
});
objectAsyncSubject.onNext("C");
objectAsyncSubject.onNext("D");
objectAsyncSubject.onComplete();
```



#### RxBus

基于RxJava实现活动间通信

```java
public class RxBus {
    // 使用一个Subject
    private final Subject<Object> mBus;

    // 静态内部类实现单例模式
    private static class Holder {
        private static final RxBus BUS = new RxBus();
    }

    private RxBus() {

        // 使用toSerialized，除了onSubscribe,onNext,onError,onComplete，都支持线程安全
        // 使用pulishsubject接受订阅后所有数据
        mBus = PublishSubject.create().toSerialized();
    }

    public static RxBus get() {
        return Holder.BUS;
    }

    public void post(Object event) {
        mBus.onNext(event);
    }

    // 转换为某种类型的被观察者
    public <T> Observable<T> toObservable(Class<T> tClass) {
        return mBus.ofType(tClass);
    }
}
```

#### RxPermission开源库

```java
private void applyPermission() {
    new RxPermission(this).request("android.permission.CAMERA")
        .compose(RxLifecycle.bindRxLifecycle(this))
        .subscribe(new Consumer<Boolean>() {
            @Override
            public void accept(Boolean aBoolean) throws Exception {
                if (aBoolean) {
                    Log.i("TAG","accept:开启了权限");
                }
            } 
        });
}
```





#### 防止快速点击

```java
TextView textView = findViewById(R.id.textView);
RxView.clicks(textView)
    .throttlrFirst(1,TimeUnit.SECONDS)
    .subscribe(new io.reactive,rxjava3.function.Consumer<Unit>() {
        @Override
        public void accept(Unit unit) throws Throwable {
            Log.i("TAG","accept:点击事件")
        }
    });
```



### [Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus](https://tech.meituan.com/2018/07/26/android-livedatabus.html)

LiveDataBus原理图

![image-20230712170041656](每日笔记/image-20230712170041656.png)



## GPT

Q：RxBus和LiveDataBus哪个好？

> A：RxBus和LiveDataBus（或者通常称为LiveEventBus）都是Android平台上常用的事件总线库，用于实现组件间的通信。它们各自有其特点和适用场景，没有绝对的"更好"之说，选择哪一个取决于你的项目需求和个人偏好。
>
> 下面我会提供一些比较和说明，帮助你理解它们的特点和区别：
>
> 1. RxBus:
>    - RxBus基于RxJava库，使用RxJava的观察者模式和发布/订阅模式实现事件通信。
>    - RxBus提供了强大的操作符和线程调度支持，可以方便地进行事件处理和线程切换。
>    - RxBus通常适用于需要更复杂的事件传递和处理逻辑的场景，或者需要跨线程进行通信的情况。
>    - RxBus可以用于任何组件之间的通信，不仅局限于ViewModel或Activity/Fragment。
>    - 它是一个自定义实现的事件总线，没有被Android官方框架提供和支持。
> 2. LiveDataBus (LiveEventBus):
>    - LiveDataBus基于Google官方的LiveData库，它可以在生命周期感知的组件（如ViewModel、Activity、Fragment等）之间传递事件。
>    - LiveDataBus为组件间的通信提供了更简单、更安全的方式，并具有生命周期感知能力，能够自动处理订阅者的生命周期管理，防止内存泄漏。
>    - LiveDataBus适用于组件间的通信，特别是ViewModel与Activity/Fragment之间的通信。
>    - LiveDataBus的事件传递是基于观察者模式，但相比RxBus，它的事件处理功能较简单，不提供丰富的操作符和线程调度支持。
>
> 综上所述，如果你对RxJava比较熟悉，需要处理更复杂的事件逻辑、线程切换和高级操作符，或者希望自由地在任何组件间进行通信，那么RxBus可能更适合你的需求。
>
> 如果你更喜欢使用官方支持的库，并且主要在ViewModel与Activity/Fragment之间进行通信，同时希望享受LiveData的生命周期感知和安全性，那么LiveDataBus就是一个不错的选择。
>
> 最终的选择取决于你的具体情况和个人偏好，你可以评估项目需求，权衡其优劣点，选择最适合你的事件总线库。



# 2023/7/13

## Java

### [弱引用](https://juejin.cn/post/6844903665241686029)

Java中的弱引用具体指的是java.lang.ref.WeakReference<T>类，我们首先来看一下官方文档对它做的说明：

弱引用对象的存在不会阻止它所指向的对象被垃圾回收器回收。弱引用最常见的用途是实现规范映射(canonicalizing mappings，比如哈希表）。

假设垃圾收集器在某个时间点决定一个对象是**弱可达的(weakly reachable)**（也就是说当前指向它的全都是弱引用），这时垃圾收集器会清除所有指向该对象的弱引用，然后把这个弱可达对象标记为可终结(finalizable)的，这样它随后就会被回收。与此同时或稍后，垃圾收集器会把那些刚清除的弱引用放入创建弱引用对象时所指定的**引用队列(Reference Queue)**中。

实际上，Java中存在四种引用，它们由强到弱依次是：强引用、软引用、弱引用、虚引用。下面我们简单介绍下除弱引用外的其他三种引用：

+ 强引用（Strong Reference）：通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的(strongly reachable)，那么它就不被回收
+ 软引用（Soft Reference）：软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些
+ 虚引用（Phantom Reference）：虚引用是Java中最弱的引用，那么它弱到什么程度呢？它是如此脆弱以至于我们通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收。

| 引用类型 | 被垃圾回收时间 |        用途        |     生存时间      |
| :------: | :------------: | :----------------: | :---------------: |
|  强引用  |    从来不会    |   对象的一般状态   | JVM停止运行时终止 |
|  软引用  |  当内存不足时  |      对象缓存      |  内存不足时终止   |
|  弱引用  | 正常垃圾回收时 |      对象缓存      |  垃圾回收后终止   |
|  虚引用  | 正常垃圾回收时 | 跟踪对象的垃圾回收 |  垃圾回收后终止   |



# 2023/7/14

## 安卓

### [Lifecycle应用](https://www.bilibili.com/video/BV1Ry4y1t7Tj?p=2&vd_source=bf286743c0f79ff4e4df2222645065d3)

LiveData会持有可被观察的数据。 并且同时它也是一种可感知生命周期的组件，意味着该组件重视其他 app组件的生命周期，如Activity、Fragment，该组件能确保，仅仅在Activity\Fragment等组件都处于 活跃的生命周期状态的时候，才去更新app组件。



#### 解耦页面与组件

计时器案例

```java
public class MyChronometer extends Chronometer implements LifecycleObserver {
    private long elapsedTime;
    public MyChronometer(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    private void startMeter() {
        setBase(SystemClock.elapsedRealtime() - elapsedTime);
        start();
    }
    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    private void stopMeter() {
        elapsedTime = SystemClock.elapsedRealtime() - getBase();
        stop();
    }
}
```

添加监听

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    initView();
    getLifecycle().addObserver(chronometer);

}
```



#### 解耦Service与组件

Service gps案例

添加依赖androidx.lifecycle_extensions

```java
public class MyLocationService extends LifecycleService {

    public MyLocationService() {
        System.out.println("MyLocationService");
        MyLocationObserver observer = new MyLocationObserver(this);
        getLifecycle().addObserver(observer);
    }
}
```

```java
public class MyLocationObserver implements LifecycleObserver {
    private Context context;
    private LocationManager locationManager;
    private MyLocationListener locationListener;

    public MyLocationObserver(Context context) {
        this.context = context;
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    private void startGetLocation() {
        locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);
        locationListener = new MyLocationListener();
        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            return;
        }
        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 3000, 1, locationListener);
    }

    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    private void stopGetLocation() {
        locationManager.removeUpdates(locationListener);
    }

    private class MyLocationListener implements LocationListener {
        @Override
        public void onLocationChanged(@NonNull Location location) {
            System.out.println("LocationChanged"+location.toString());
        }
        @Override
        public void onLocationChanged(@NonNull List<Location> locations) {             
            System.out.println("LocationChanged"+locations.toString());
        }
        @Override
        public void onProviderEnabled(@NonNull String provider) {
        }
        @Override
        public void onProviderDisabled(@NonNull String provider) {
        }
    }
```



```shel
// adb 修改 gps 定位
adb -s emulator-5554 emu geo fix 122.4961236714487 31.24010934431376
```

#### ProcessLifecycleOwner监听应用程序生命周期

```java
// Application中添加
ProcessLifecycleOwner.get().getLifecycle().addObserver(new ApplicationObserver());
```

```java
public class ApplicationObserver implements LifecycleObserver {
    private String TAG = "";
    
    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)
    public void onCreate() {Log.d(TAG,"Lifecycle.Event.ON_CREATE");}
    
    @OnLifecycleEvent(Lifecycle.Event.ON_START)
    public void onStart() {Log.d(TAG,"Lifecycle.Event.ON_START");}
    
    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    public void onResume() {Log.d(TAG,"Lifecycle.Event.ON_RESUME");}
    
    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void onPause() {Log.d(TAG,"Lifecycle.Event.ON_PAUSE");}
    
    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)
    public void onStop() {Log.d(TAG,"Lifecycle.Event.ON_STOP");}
    
    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    public void onDestroy() {Log.d(TAG,"Lifecycle.Event.ON_DESTROY");}
}
```



LiveData

```java
private MutableLiveData<Integer> currentSecond
```



```java
// 非UI线程 postValue
// UI线程 setValue
viewModel.getCurrentSecond().postValue(viewModel.getCurrentSecond().getValue()+1);
```



### LiveData

#### 应用

1.在ViewModel类里面创建LiveData

2.在Activity里面添加处理 `使用 LiveData 对象的 observe 或 observeForever 方法将对应的 Activity 或 Fragment 等添加为该 LiveData 对象的观察者`

3.使用LiveData的setValue或postValue更新数据，然后在Activity/Fragment中会自动刷新界面了

#### 原理

LiveData核心其实主要就是observer方法，注册观察者，用于监听数据变化；还有就是setValue方法用于通知数据变更；为什么LiveData比较好用呢，因为它可以监听界面生命周期用于刷新数据，也不需要用户自行切换线程。

[LiveData使用](https://www.jianshu.com/p/c69a7db3299a)



### 快捷键

设置为全局变量 `ctrl+alt+F`





# 2023/7/17

## 安卓

### Lifecycle源码分析

#### Event & State

7种Event

+ ON_CREATE
+ ON_START
+ ON_RESUME
+ ON_PAUSE
+ ON_STOP
+ ON_DESTROY
+ ON_ANY

5种State

+ DESTROY
+ INITIALIZED
+ CREATE
+ STARTED
+ RESUME

State是当前Lifecycle的状态值，Event是Lifecycle接下去的动作值



#### 注册 & 发送

观察者队列数据结构FastSafeIterableMap

```java
@Override
public void addObserver(@NonNull LifecycleObserver observer){...}
```

发送，以resume为例

```java
 @Override
protected void onResume() {
    super.onResume();
    
    //'1.直接发送State,告诉要跳到这个State状态'
    registry.markState(Lifecycle.State.CREATED);
    
    //'2.直接的是Event，然后跳到相应的Event对应的State状态'
    registry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);
 
}
```







### 广播动态注册和静态注册

动态注册的广播接收器可以自由实现注册和取消，有很大的灵活性，只有在程序启动后才能接收到广播。在onDestroy中unregisterReceiver注销，广播接收器的生命周期和当前Activity的生命周期一样。

静态注册的广播不受程序是否启动的约束，当应用程序关闭后，还是可以接受到广播。

标准广播和有序广播的接收和发送都是全局性的，这样会使得其他应用程序有几率接收到广播，会造成一定的安全问题。为了解决这个问题，Android系统中有一套本地广播机制，让所有广播事件在程序内部完成，采用localBroadcastReceiver对广播管理。



# 2023/7/18

## 安卓

### layout-land

`layout`:一般布局

`layout-port`:必须更改为纵向的小部件的布局

`layout-land`:必须为横向而改变的小部件的布局

> 1. 将res/layout-land/main.xml这个文件重命名为activity_main.xml，或者将竖向布局文件res/layout/activity_main.xml改为main.xml，总之，两个文件名要一样，这是重点！
> 2. 这样，Activity每次横竖屏切换才能正确调用函数，屏幕切换成横向的时候res/layout-land/main.xml会被自动加载。



```java
private void initLandScapeView() {
    //自检计数
    selfRl = findViewById(R.id.relative_selfCheck);        
    middleTitle = findViewById(R.id.tv_middle_title);
    
    //网络连接
    landTvInterNetStatus = findViewById(R.id.tv_interNetStatus_land);    
    landPbInterNet = findViewById(R.id.processBar_intenNet_land);

        
    //辅助背景灯
    landTvCameraLightStatus = findViewById(R.id.tv_cameraLightStatus_land);
    landPbCameraLight = findViewById(R.id.processBar_cameraLight_land);
    
    ...
}
```



[TypeToken](https://blog.csdn.net/qq_43842093/article/details/128140951)

Gson解析时`TypeToken`的泛型参数只能使用时传入**确切的类型**才能获取正确的Type，这也是`TypeToken`设计成抽象类的巧妙之处和原因（改为只有protected构造方法的普通类原理一样）。一旦将`TypeToken`改成普通类，根据上面的分析，一切类型信息都被擦除，Gson解析将得不到预期的类型。



### [Lifecycle指南](https://developer.android.google.cn/topic/libraries/architecture/lifecycle?hl=zh-cn#implementing-lco)

对于位置跟踪示例，我们可以让 `MyLocationListener` 类实现 [`DefaultLifecycleObserver`](https://developer.android.google.cn/reference/androidx/lifecycle/DefaultLifecycleObserver?hl=zh-cn)，然后在 `onCreate()` 方法中使用 activity 的 [`Lifecycle`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle?hl=zh-cn) 对其进行初始化。这样，`MyLocationListener` 类便可以“自给自足”，这意味着，**对生命周期状态的变化做出响应的逻辑会在 `MyLocationListener`（而不是在 activity）中进行声明**。让各个组件存储自己的逻辑可使 activity 和 fragment 逻辑更易于管理。

> 在给出的示例中，MyLocationListener 类实现了 DefaultLifecycleObserver 接口。在 Activity 的 onCreate() 方法中，会使用 Activity 的 Lifecycle 对 MyLocationListener 进行初始化。这样，MyLocationListener 类就能够独立处理其自身相关的生命周期状态变化，而不需要依赖于外部的 Activity。这种方式可以使各个组件将自己的逻辑存储在自己内部，使得 Activity 和 Fragment 的逻辑更易于管理。



处理 ON_STOP 事件

如果 [`Lifecycle`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle?hl=zh-cn) 属于 `AppCompatActivity` 或 `Fragment`，那么调用 `AppCompatActivity` 或 `Fragment` 的 `onSaveInstanceState()` 时，[`Lifecycle`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle?hl=zh-cn) 的状态会更改为 [`CREATED`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.State?hl=zh-cn#CREATED) 并且会分派 [`ON_STOP`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.Event?hl=zh-cn#ON_STOP) 事件。

通过 `onSaveInstanceState()` 保存 `Fragment` 或 `AppCompatActivity` 的状态后，其界面被视为不可变，直到调用 [`ON_START`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.Event?hl=zh-cn#ON_START)。如果在保存状态后尝试修改界面，很可能会导致应用的导航状态不一致，因此如果应用在保存状态后运行 `FragmentTransaction`，`FragmentManager` 会抛出异常。如需了解详情，请参阅 `commit()`。

[`LiveData`](https://developer.android.google.cn/reference/androidx/lifecycle/LiveData?hl=zh-cn) 本身可防止出现这种极端情况，方法是在其观察者的关联 [`Lifecycle`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle?hl=zh-cn) 还没有至少处于 [`STARTED`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.State?hl=zh-cn#STARTED) 状态（没到STARTED或RESUMED）时避免调用其观察者。在后台，它会在决定调用其观察者之前调用 [`isAtLeast()`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.State?hl=zh-cn#isAtLeast(androidx.lifecycle.Lifecycle.State))。

遗憾的是，`AppCompatActivity` 的 `onStop()` 方法会在 `onSaveInstanceState()` 之后调用，这样就会留下一个缺口，即不允许界面状态发生变化，但 [`Lifecycle`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle?hl=zh-cn) 尚未移至 [`CREATED`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.State?hl=zh-cn#CREATED) 状态。

为防止出现这个问题，`beta2` 及更低版本中的 [`Lifecycle`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle?hl=zh-cn) 类会将状态标记为 [`CREATED`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.State?hl=zh-cn#CREATED) 而不分派事件，这样一来，即使未分派事件（直到系统调用 `onStop()`），检查当前状态的代码也会获得真实值。

遗憾的是，此解决方案有两个主要问题：

- 在 API 23 及更低级别，Android 系统实际上会保存 activity 的状态，即使它的一部分被另一个 activity 覆盖。换句话说，Android 系统会调用 `onSaveInstanceState()`，但不一定会调用 `onStop()`。这样可能会产生很长的时间间隔，在此时间间隔内，观察者仍认为生命周期处于活动状态，虽然无法修改其界面状态。
- 任何要向 [`LiveData`](https://developer.android.google.cn/reference/androidx/lifecycle/LiveData?hl=zh-cn) 类公开类似行为的类都必须实现由 [`Lifecycle`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle?hl=zh-cn) 版本 `beta 2` 及更低版本提供的解决方法。

[ComponentActivity/Fragment是如何在生命周期方法发生改变时触发了LifecycleObserver中使用OnLifecycleEvent注解的方法?](https://blog.csdn.net/meijing11/article/details/121372541)





## GPT

Q：判断某个布局id不为0

> A：在Android中，判断某个布局的id是否为0是指检查给定的布局资源标识符（ID）是否为0。布局的ID是在XML布局文件中定义的，用于在Java代码中引用该布局。通常，布局的ID用于在运行时找到并操作该布局。当我们判断某个布局的ID是否为0时，我们是在检查该布局是否已被正确定义和初始化。
> 如果某个布局的ID为0，意味着该布局的ID未被正确赋值或者没有找到对应的布局资源文件。这可能发生在以下情况下：
>
> 1.布局资源文件中未正确定义该布局的ID。
> 2.在Java代码中引用布局时，错误地使用了无效的ID。
> 3.在运行时，没有找到匹配的布局资源文件。
>
> 因此，判断某个布局的ID是否不为0，可以作为一种验证的手段，确保我们在使用布局资源之前，先正确初始化和定义了相应的布局ID



Q：inflater.inflate()作用

> A：inflater.inflate 是在Android中用于将布局资源文件实例化为具体的视图对象的方法。它的主要作用是将定义在XML布局文件中的视图层次结构转换为对应的实际视图对象。
> 当我们需要在代码中使用一个XML布局文件时，我们可以使用LayoutInflater类的inflate方法来实现。这个方法接收三个参数：
>
> 1.布局资源文件的ID：指定要实例化的布局文件的ID。
> 2.父级容器：指定要将布局文件添加到的父级容器，通常是一个ViewGroup对象。
> 3.是否将实例化的视图添加到父级容器中：一个布尔值，指示是否将实例化的视图对象添加到父级容器中。
>
> 该方法会返回一个指向实例化的视图对象的引用。通过这个方法，我们可以将一个布局文件转换为在代码中操作的具体视图对象，然后可以对这个实例化的视图对象进行操作、设置属性或者作为布局的一部分添加到父容器中。
> 以下是一个示例代码，演示了如何使用inflater.inflate方法实例化一个布局文件：
> LayoutInflater inflater = LayoutInflater.from(context);
> View rootView = inflater.inflate(R.layout.my_layout, parentContainer, false);
>
> 在这个代码示例中，我们使用LayoutInflater.from方法获取一个LayoutInflater实例，并调用它的inflate方法来实例化R.layout.my_layout布局文件。我们指定了parentContainer作为父级容器，并且设置最后一个参数为false，表示不将实例化的视图添加到父级容器中。最后，我们将得到的视图对象赋值给变量rootView，以便后续的操作和使用。
> 这样，我们就可以通过rootView对象访问布局中的各个视图，并对其进行操作和设置属性。



Q：什么情况下ViewModel存在的时间比activity长，不会在activity执行onDestroy时被销毁吗

> A：在某些情况下，ViewModel 的生命周期可能会比关联的 Activity 更长，导致在 Activity 执行 onDestroy() 方法时仍然存在。
>
> 这种情况通常发生在以下情况下：
>
> 1. 配置变化：当发生配置变化，例如屏幕旋转、语言切换或夜间模式切换时，Activity 会被销毁并重新创建。然而，ViewModel 实例会被保留下来并重新关联到新创建的 Activity，以便在配置变化后继续使用之前保存的数据状态。因此，ViewModel 的生命周期会比 Activity 更长。
> 2. 内存不足时的进程终止恢复：在 Android 系统面临内存不足的情况下，为了回收内存资源，系统可能会终止进程。当进程重新启动时，之前创建的 ViewModel 实例会通过 ViewModelProviders 类或 ViewModelProvider 构造函数被重新创建，并且会与新创建的 Activity 关联，从而使 ViewModel 的生命周期比 Activity 更长。
>
> 在这些情况下，如果 ViewModel 中持有对 Activity 的引用，就会出现内存泄漏的问题。因为即使 Activity 已经执行 onDestroy() 方法并准备销毁时，由于 ViewModel 仍然存在并持有对 Activity 的引用，导致 Activity 无法被垃圾回收器正确处理。
>
> 为了避免这种泄漏，建议在编写 ViewModel 时避免直接引用 View 或 Activity 上下文。相反，ViewModel 应该专注于管理数据和业务逻辑，不应该包含与 View 或 Activity 直接相关的引用。如果需要执行某些与 View 相关的操作，可以使用 LiveData 或观察者模式，在界面上观察 ViewModel 中的数据变化并做出相应的响应。
>
> 总结而言，ViewModel 应该是独立于 Activity 或 Fragment 的，避免直接引用 View 或 Activity 上下文，以避免潜在的内存泄漏问题。



Q：哪些情况下会调用onSaveInstanceState()

> A：onSaveInstanceState() 方法是在 Activity 或 Fragment 即将被销毁之前调用的生命周期方法，用于保存当前状态的数据。以下是几种情况下会调用 onSaveInstanceState() 方法：
>
> 1.配置变化：当发生配置变化时，例如屏幕旋转、语言切换或夜间模式切换，系统会销毁并重新创建 Activity 或 Fragment。在销毁之前，系统会调用 onSaveInstanceState() 方法，允许开发者保存当前状态的数据。接着，在重新创建的实例中，开发者可以通过 onCreate() 方法中的 savedInstanceState 参数恢复之前保存的状态数据。
> 2.后台进程被终止：在 Android 系统面临内存不足的情况下，为了回收系统资源，系统可能会终止后台进程。在这种情况下，当前可见的 Activity 或 Fragment 实例通常会被保留下来，以便在进程重新启动时恢复其状态。在进程终止之前，系统会调用 onSaveInstanceState() 方法，用于保存当前状态的数据，以便在进程重新启动后恢复。
> 3.用户按下后退键：当用户按下设备的后退键，导致当前 Activity 或 Fragment 即将被销毁时，系统会调用 onSaveInstanceState() 方法，以便保存当前状态的数据。这样，在用户返回到该界面时，开发者可以通过 onCreate() 方法中的 savedInstanceState 参数恢复之前保存的状态数据。
>
> 需要注意的是，onSaveInstanceState() 方法仅适用于保存一小段关键性质的数据，例如用于恢复用户界面的信息。不应该将大量数据存储在 savedInstanceState 中，以免影响性能和内存消耗。对于大型数据集或需要持久化存储的数据，应该考虑使用其他机制，如持久化到数据库或使用 SharedPreferences 等。
> 总结而言，onSaveInstanceState() 方法会在配置变化、后台进程终止和用户按下后退键等情况下被调用，用于保存当前状态的数据。通过合理使用该方法，开发者可以在应用程序发生变化或重新创建后恢复之前保存的状态数据





# 2023/7/20

## 安卓

### [onNewIntent与启动模式](https://juejin.cn/post/6844904007085850631?searchId=202307200909302BD8DECAA57F1ED65C1C)

