#### 多线程并发模型

+ 内存共享模型

  这些线程依赖统一内存并且都有权限访问，线程访问内存前需要抢占并锁定内存的使用权，没有抢占到内存的线程需要等待其他线程释放使用权再执行。

+ Actor模型

  Actor并发模型基于消息通信并发模型的典型代表，每一个线程都是一个独立Actor，每个Actor有自己独立的内存，Actor之间通过消息传递机制出发对方Actor的行为，不同Actor之间不能直接访问对方的内存空间。
  Actor并发模型对比内存共享并发模型的优势在宇不同线程间内存隔离，不会产生不同线程竞争统一内存资源的问题。开发者不需要考虑对内存上锁导致的一系列功能、性能问题，提升了开发效率。



#### TaskPool & Worker

|                  |                                                              |                                                              |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 内存模型         | 线程间隔离、内存不共享                                       | 线程间隔离，内存不共享                                       |
| 参数传递         | 标准的结构化克隆算法进行序列化、反序列化、完成参数传递。支持ArrayBuffer转移和SharedArrayBuffer共享。 | 标准的结构化克隆算法进行序列化、反序列化、完成参数传递。支持ArrayBuffer转移和SharedArrayBuffer共享。 |
| 参数传递         | 直接传递，无需封装                                           | 消息对象唯一参数，需要自己封装                               |
| 方法调用         | 直接将方法传入调用                                           | 在Worker线程中进行消息解析并调用对应的方法                   |
| 返回值           | 异步调用后默认返回                                           | 主动发送消息，需要在onmessage解析赋值                        |
| 生命周期         | TaskPool自行管理生命周期，无需关心任务负载高低               | 开发者自行管理Worker的数量及生命周期                         |
| 任务池个数上限   | 自动管理，无需配置                                           | 最多开启8个Worker                                            |
| 任务执行时长上限 | 3分钟（不包含Promise和async/await异步调用的耗时，例如网络下载、文件读写等I/O任务的耗时） | 无限制                                                       |
| 设置任务的优先级 | 支持配置任务优先级                                           | 不支持                                                       |
| 执行任务的取消   | 支持取消已经发起的任务                                       | 不支持                                                       |



async/await不能直接在for循环使用
