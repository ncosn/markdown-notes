# 应用模型

## 应用模型概述

### 应用模型的构成要素

应用模型是系统为开发者提供的应用程序所需能力的抽象提炼，它提供了应用程序必备的组件和运行机制。有了应用模型，开发者可以基于一套统一的模型进行应用开发，使应用开发更简单、高效。

应用模型的构成要素包括：

1. 应用组件

   应用组件是应用的基本组成单位，是应用的运行入口。用户启动、使用和退出应用过程中，应用组件会在不同的状态间切换，这些状态称为应用组件的生命周期。应用组件提供生命周期的回调函数，开发者通过应用组件的生命周期回调感知应用的[状态变化](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-lifecycle.md)。应用开发者在编写应用时，首先需要编写的就是应用组件，同时还需编写应用组件的生命周期回调函数，并在应用配置文件中配置相关信息。这样，操作系统在运行期间通过配置文件创建应用组件的实例，并调度它的生命周期回调函数，从而执行开发者的代码。

2. 应用进程模型

   应用进程模型定义应用进程的创建和销毁方式，以及进程间的通信方式。

3. 应用线程模型

   应用线程模型定义应用进程内线程的创建和销毁方式、主线程和UI线程的创建方式、线程间的通信方式。

4. 应用任务管理模型（仅对系统应用开放）

   应用任务管理模型定义任务（Mission）的创建和销毁方式，以及任务与组件间的关系。所谓任务，即用户使用一个应用组件实例的记录。每次用户启动一个新的应用组件实例，都会生成一个新的任务。例如，用户启动一个视频应用，此时在“最近任务”界面，将会看到视频应用这个任务，当用户点击这个任务时，系统会把该任务切换到前台，如果这个视频应用中的视频编辑功能也是通过应用组件编写的，那么在用户启动视频编辑功能时，会创建视频编辑的应用组件实例，在“最近任务”界面中，将会展示视频应用、视频编辑两个任务。

5. 应用配置文件

   应用配置文件中包含应用配置信息、应用组件信息、权限信息、开发者自定义信息等，这些信息在编译构建、分发和运行阶段分别提供给编译工具、应用市场和操作系统使用。





#### 应用模型解读

##### 应用模型概况

随着系统的演进发展，先后提供了两种应用模型：

- FA（Feature Ability）模型：API 7开始支持的模型，已经不再主推。
- Stage模型：API 9开始新增的模型，是目前主推且会长期演进的模型。在该模型中，由于提供了AbilityStage、WindowStage等类作为应用组件和Window窗口的“舞台”，因此称这种应用模型为Stage模型。

Stage模型之所以成为主推模型，源于其设计思想。Stage模型的设计基于如下出发点。

1. **为复杂应用而设计**

   - 多个应用组件共享同一个ArkTS引擎（运行ArkTS语言的虚拟机）实例，应用组件之间可以方便的共享对象和状态，同时减少复杂应用运行对内存的占用。
   - 采用面向对象的开发方式，使得复杂应用代码可读性高、易维护性好、可扩展性强。

2. **原生支持应用组件级的跨端迁移和多端协同**

   Stage模型实现了应用组件与UI解耦：

   - 在跨端迁移场景下，系统在多设备的应用组件之间迁移数据/状态后，UI便可利用ArkUI的声明式特点，通过应用组件中保存的数据/状态恢复用户界面，便捷实现跨端迁移。
   - 在多端协同场景下，应用组件具备组件间通信的RPC调用能力，天然支持跨设备应用组件的交互。

3. **支持多设备和多窗口形态**

   应用组件管理和窗口管理在架构层面解耦：

   - 便于系统对应用组件进行裁剪（无屏设备可裁剪窗口）。
   - 便于系统扩展窗口形态。
   - 在多设备（如桌面设备和移动设备）上，应用组件可使用同一套生命周期。

4. **平衡应用能力和系统管控成本**

   Stage模型重新定义应用能力的边界，平衡应用能力和系统管控成本。

   - 提供特定场景（如服务卡片、输入法）的应用组件，以便满足更多的使用场景。
   - 规范化后台进程管理：为保障用户体验，Stage模型对后台应用进程进行了有序治理，应用程序不能随意驻留在后台，同时应用后台行为受到严格管理，防止恶意应用行为。



## 通过对比认识FA模型与Stage模型

**Stage模型与FA模型最大的区别在于**：Stage模型中，多个应用组件共享同一个ArkTS引擎实例；而FA模型中，每个应用组件独享一个ArkTS引擎实例。因此在Stage模型中，应用组件之间可以方便的共享对象和状态，同时减少复杂应用运行对内存的占用。Stage模型作为主推的应用模型，开发者通过它能够更加便利地开发出分布式场景下的复杂应用。

可通过如下对比表格了解两种模型的整体概况。

**表1** FA模型与Stage模型差异概览

| 项目             | FA模型                                                       | Stage模型                                                    |
| :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **应用组件**     | 1. 组件分类 ![fa-model-component](./开发者文档——开发.assets/fa-model-component.png)  - PageAbility组件：包含UI，提供展示UI的能力。详细介绍请参见[PageAbility组件概述](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/pageability-overview.md)。   <br />- ServiceAbility组件：提供后台服务的能力，无UI。详细介绍请参见[ServiceAbility组件概述](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/serviceability-overview.md)。   <br />- DataAbility组件：提供数据分享的能力，无UI。详细介绍请参见[DataAbility组件概述](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/dataability-overview.md)。 2. 开发方式   通过导出匿名对象、固定入口文件的方式指定应用组件。开发者无法进行派生，不利于扩展能力。 | 1. 组件分类 ![stage-model-component](./开发者文档——开发.assets/stage-model-component.png)  - UIAbility组件：包含UI，提供展示UI的能力，主要用于和用户交互。详细介绍请参见[UIAbility组件概述](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-overview.md)。   <br />- ExtensionAbility组件：提供特定场景（如卡片、输入法）的扩展能力，满足更多的使用场景。详细介绍请参见[ExtensionAbility组件概述](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/extensionability-overview.md)。 <br />2. 开发方式   采用**面向对象**的方式，将**应用组件以类接口的形式开放**给开发者，可以进行派生，利于扩展能力。 |
| **进程模型**     | 有两类进程： 1. 主进程 2. 渲染进程 详细介绍请参见[进程模型](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/process-model-fa.md)。 | 有**三类进程**： 1. 主进程 2. ExtensionAbility进程 3. 渲染进程 <br />详细介绍请参见[进程模型](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/process-model-stage.md)。 |
| **线程模型**     | 1. ArkTS引擎实例的创建   一个进程可以运行多个应用组件实例，每个应用组件实例运行在一个单独的ArkTS引擎实例中。 2. 线程模型   每个ArkTS引擎实例都在一个单独线程（非主线程）上创建，主线程没有ArkTS引擎实例。 3. 进程内对象共享：不支持。 详细介绍请参见[线程模型](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/thread-model-fa.md)。 | 1. ArkTS引擎实例的创建   **一个进程可以运行多个应用组件实例**，所有应用组件实例共享一个ArkTS引擎实例。 <br />2. 线程模型   ArkTS引擎实例在主线程上创建。 <br />3. 进程内对象共享：支持。 详细介绍请参见[线程模型](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/thread-model-stage.md)。 |
| **任务管理模型** | - 每个PageAbility组件实例创建一个任务。 - 任务会持久化存储，直到超过最大任务个数（根据产品配置自定义）或者用户主动删除任务。 - PageAbility组件之间不会形成栈的结构。 详细介绍请参见[任务管理场景介绍](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/mission-management-overview.md)。 | - **每个UIAbility组件实例创建一个任务**。 <br />- **任务会持久化存储**，直到超过最大任务个数（根据产品配置自定义）或者用户主动删除任务。 <br />- UIAbility组件之间不会形成栈的结构。 详细介绍请参见[任务管理场景介绍](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/mission-management-overview.md)。 |
| **应用配置文件** | 使用config.json描述应用信息、HAP信息和应用组件信息。 详细介绍请参见[应用配置文件概述（FA模型）](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/application-configuration-file-overview-fa.md)。 | 使用app.json5描述应用信息，module.json5描述HAP信息、应用组件信息。 详细介绍请参见[应用配置文件概述（Stage模型）](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/application-configuration-file-overview-stage.md)。 |



### Stage模型开发概述

#### 基本概念

下图展示了Stage模型中的基本概念。

**图1** Stage模型概念图
![stage-concepts](./开发者文档——开发.assets/stage-concepts.png)

- [UIAbility组件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-overview.md)和[ExtensionAbility组件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/extensionability-overview.md)

  Stage模型提供`UIAbility`和`ExtensionAbility`两种类型的组件，这两种组件都有具体的类承载，支持面向对象的开发方式。

  - UIAbility组件是一种**包含UI的应用组件**，主要用于和用户交互。例如，图库类应用可以在UIAbility组件中展示图片瀑布流，在用户选择某个图片后，在新的页面中展示图片的详细内容。同时用户可以通过返回键返回到瀑布流页面。UIAbility组件的生命周期只包含创建/销毁/前台/后台等状态，与显示相关的状态通过WindowStage的事件暴露给开发者。
  - ExtensionAbility组件是一种**面向特定场景的应用组件**。开发者并不直接从ExtensionAbility组件派生，而是需要使用ExtensionAbility组件的派生类。**目前ExtensionAbility组件有用于卡片场景的FormExtensionAbility**，**用于输入法场景的InputMethodExtensionAbility**，**用于闲时任务场景的WorkSchedulerExtensionAbility等多种派生类**，这些派生类都是基于特定场景提供的。例如，用户在桌面创建应用的卡片，需要应用开发者从FormExtensionAbility派生，实现其中的回调函数，并在配置文件中配置该能力。**ExtensionAbility组件的派生类实例由用户触发创建，并由系统管理生命周期**。在Stage模型上，三方应用开发者不能开发自定义服务，而需要根据自身的业务场景通过ExtensionAbility组件的派生类来实现。

- [WindowStage](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/windowmanager/application-window-stage.md)

  每个UIAbility实例都会与一个WindowStage类实例绑定，该类起到了应用进程内窗口管理器的作用。它包含一个**主窗口**。也就是说**UIAbility实例通过WindowStage持有了一个主窗口，该主窗口为ArkUI提供了绘制区域**。

- [Context](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/application-context-stage.md)

  在Stage模型上，Context及其派生类向开发者提供在运行期可以调用的各种资源和能力。UIAbility组件和各种ExtensionAbility组件的派生类都有各自不同的Context类，他们都继承自基类Context，但是各自又根据所属组件，提供不同的能力。

- [AbilityStage](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/abilitystage.md)

  每个Entry类型或者Feature类型的HAP在运行期都有一个AbilityStage类实例，当HAP中的代码首次被加载到进程中的时候，系统会先创建AbilityStage实例。



#### 开发流程

基于Stage模型开发应用时，在应用模型部分，涉及如下开发过程。

**表1** Stage模型开发流程

| 任务         | 简介                                                         | 相关指导                                                     |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 应用组件开发 | 本章节介绍了如何使用Stage模型的UIAbility组件和ExtensionAbility组件开发应用。 | - [应用/组件级配置](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/application-component-configuration-stage.md) - [UIAbility组件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-overview.md) - [ExtensionAbility组件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/extensionability-overview.md) - [AbilityStage组件容器](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/abilitystage.md) - [应用上下文Context](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/application-context-stage.md) - [组件启动规则](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/component-startup-rules.md) |
| 了解进程模型 | 本章节介绍了Stage模型的进程模型以及几种常用的进程间通信方式。 | [进程模型概述](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/process-model-stage.md) |
| 了解线程模型 | 本章节介绍了Stage模型的线程模型以及几种常用的线程间通信方式。 | [线程模型概述](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/thread-model-stage.md) |
| 任务管理     | 本章节介绍了Stage模型中任务管理的基本概念和典型场景。        | - [任务管理场景介绍](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/mission-management-overview.md) - [任务管理与启动模式](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/mission-management-launch-type.md) - [页面栈和任务链](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/page-mission-stack.md) |
| 应用配置文件 | 本章节介绍Stage模型中应用配置文件的开发要求。                | [Stage模型应用配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/config-file-stage.md) |



### 应用/组件级配置

在开发应用时，需要配置应用的一些标签，例如应用的包名、图标等表示特征的属性。本文描述了在开发应用需要配置的一些关键标签。

图标和标签通常一起配置，可以分为应用图标、应用标签和入口图标、入口标签，分别对应[app.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/app-configuration-file.md)和[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)中的icon和label标签。

**应用图标和标签是在设置应用中使用**，例如设置应用中的应用列表。**入口图标是应用安装完成后在设备桌面上显示出来的**。

- **应用包名配置**

  应用需要在工程的AppScope目录下的[app.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/app-configuration-file.md)中配置bundleName标签，该标签用于标识应用的唯一性。推荐采用反域名形式命名（如com.example.demo，建议第一级为域名后缀com，第二级为厂商/个人名，第三级为应用名，也可以多级）。

- **应用图标和标签配置**

  Stage模型的应用需要配置应用图标和应用标签。应用图标和标签是在设置应用中使用，例如设置应用中的应用列表，会显示出对应的图标和标签。

  **应用图标**需要在工程的`AppScope`目录下的[app.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/app-configuration-file.md)中配置icon标签。应用图标**需配置为图片的资源索引**，配置完成后，该图片即为应用的图标。

  **应用标签**需要在工程的`AppScope`模块下的[app.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/app-configuration-file.md)中配置label标签。标识应用对用户显示的名称，**需要配置为字符串资源的索引**。

  ```json
  {
    "app": {
      "icon": "$media:app_icon",
      "label": "$string:app_name"
      ...
    }
  }
  ```

- **入口图标和标签配置**

  Stage模型支持对组件配置入口图标和入口标签。入口图标和入口标签会显示在桌面上。

  **入口图标**需要在[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)中配置，在`abilities`标签下面有`icon`标签。例如**希望在桌面上显示该UIAbility的图标**，则需要在`skills`标签下面的entities中添加"entity.system.home"、actions中添加"ohos.want.action.home"。同**一个应用有多个UIAbility配置上述字段时，桌面上会显示出多个图标，分别对应各自的UIAbility。**

  ```json
  {
    "module": {
      ...
      "abilities": [
        {
          // $开头的为资源值
          "icon": "$media:icon",
          "label": "$string:EntryAbility_label",
          "skills": [
            {
              "entities": [
                "entity.system.home"
              ],
              "actions": [
                "ohos.want.action.home"
              ]
            }
          ],
        }
      ]
    }
  }
  ```

  **系统对无图标应用严格管控，防止一些恶意应用故意配置无入口图标，导致用户找不到软件所在的位置，无法操作卸载应用，在一定程度上保证用户终端设备的安全。**

  如果应用确需隐藏入口图标，需要配置AllowAppDesktopIconHide应用特权，具体配置方式参考[应用特权配置指南](https://docs.openharmony.cn/pages/v4.0/zh-cn/device-dev/subsystems/subsys-app-privilege-config-guide.md)。详细的入口图标及入口标签的显示规则如下。

  1.HAP中包含UIAbility

  - 在module.json5配置文件的abilities标签中设置了入口图标
    - 该应用没有隐藏图标的特权
      - 系统将使用该UIAbility配置的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到该UIAbility首页。
      - 系统将使用该UIAbility配置的label作为入口标签，并显示在桌面上，如果没有配置label，系统将使用app.json5中的label作为入口标签，并显示在桌面上。
    - 该应用具有隐藏图标的特权
      - 桌面应用查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。
  - 在module.json5配置文件的abilities标签中未设置入口图标
    - 该应用没有隐藏图标的特权
      - 系统将使用app.json5中的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面，如下图所示。
      - 系统将使用app.json5中的label作为入口标签，并显示在桌面上。
    - 该应用具有隐藏图标的特权
      - 桌面应用查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。

  2.HAP中不包含UIAbility

  - 该应用没有隐藏图标的特权
    - 系统将使用app.json5中的icon作为入口图标，并显示在桌面上。用户点击该图标，页面跳转到应用管理中对应的应用详情页面，如下图所示。
    - 系统将使用app.json5中的label作为入口标签，并显示在桌面上。
  - 该应用具有隐藏图标的特权
    - 桌面应用查询时不返回应用信息，不会在桌面上显示对应的入口图标和标签。

- **应用版本声明配置**

  应用版本声明需要在工程的AppScope目录下的[app.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/app-configuration-file.md)中配置versionCode标签和versionName标签。versionCode用于标识应用的版本号，该标签值为32位非负整数。此数字仅用于确定某个版本是否比另一个版本更新，数值越大表示版本越高。versionName标签标识版本号的文字描述。

- **Module支持的设备类型配置**

  Module支持的设备类型需要在[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)中配置[deviceTypes标签](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md#devicetypes标签)，如果deviceTypes标签中添加了某种设备，则表明当前的Module支持在该设备上运行。

- **Module权限配置**

  Module访问系统或其他应用受保护部分所需的权限信息需要在[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)中配置[requestPermissions标签](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md#requestpermissions标签)。该标签用于声明需要申请权限的名称、申请权限的原因以及权限使用的场景。



### UIAbility组件概述

#### 概述

UIAbility组件是一种包含UI的应用组件，主要用于和用户交互。

UIAbility的设计理念：

1. **原生支持应用组件级的跨端迁移和多端协同**。
2. **支持多设备和多窗口形态**。

> **说明：**
>
> 详细请参见[Stage模型的设计理念](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/application-model-description.md)。

UIAbility划分原则与建议：

UIAbility组件是系统调度的基本单元，为应用提供绘制界面的窗口。一个应用可以包含一个或多个UIAbility组件。例如，在支付应用中，可以将入口功能和收付款功能分别配置为独立的UIAbility。

每一个UIAbility组件实例都会在最近任务列表中显示一个对应的任务。

对于开发者而言，可以根据具体场景选择单个还是多个UIAbility，划分建议如下：

- 如果开发者希望在任务视图中看到一个任务，则建议使用一个UIAbility，多个页面的方式。
- 如果开发者希望在任务视图中看到多个任务，或者需要同时开启多个窗口，则建议使用多个UIAbility开发不同的模块功能。

#### 声明配置

为使应用能够正常使用UIAbility，需要在[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)的[abilities标签](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md#abilities标签)中声明UIAbility的名称、入口、标签等相关信息。

```json
{
  "module": {
    ...
    "abilities": [
      {
        "name": "EntryAbility", // UIAbility组件的名称
        "srcEntry": "./ets/entryability/EntryAbility.ts", // UIAbility组件的代码路径
        "description": "$string:EntryAbility_desc", // UIAbility组件的描述信息
        "icon": "$media:icon", // UIAbility组件的图标
        "label": "$string:EntryAbility_label", // UIAbility组件的标签
        "startWindowIcon": "$media:icon", // UIAbility组件启动页面图标资源文件的索引
        "startWindowBackground": "$color:start_window_background", // UIAbility组件启动页面背景颜色资源文件的索引
        ...
      }
    ]
  }
}
```



### UIAbility组件生命周期

#### 概述

当用户打开、切换和返回到对应应用时，应用中的UIAbility实例会在其生命周期的不同状态之间转换。UIAbility类提供了一系列回调，通过这些回调可以知道当前UIAbility实例的某个状态发生改变，会经过UIAbility实例的创建和销毁，或者UIAbility实例发生了前后台的状态切换。

UIAbility的生命周期包括Create、Foreground、Background、Destroy四个状态，如下图所示。

**图1** UIAbility生命周期状态
![Ability-Life-Cycle](./开发者文档——开发.assets/Ability-Life-Cycle.png)

#### 生命周期状态说明

##### Create状态

Create状态为在应用加载过程中，UIAbility实例创建完成时触发，系统会调用`onCreate()`回调。可以在该回调中进行**页面初始化操作**，例如变量定义资源加载等，用于后续的UI展示。

```ts
import UIAbility from '@ohos.app.ability.UIAbility';
import AbilityConstant from '@ohos.app.ability.AbilityConstant';
import Want from '@ohos.app.ability.Want';

export default class EntryAbility extends UIAbility {
  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
    // 页面初始化
  }
  // ...
}
```

> **说明**：
>
> [Want](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-want.md)是对象间信息传递的载体，可以用于应用组件间的信息传递。Want的详细介绍请参见[信息传递载体Want](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/want-overview.md)。

##### WindowStageCreate和WindowStageDestroy状态

UIAbility实例创建完成之后，在进入Foreground之前，系统会创建一个WindowStage。WindowStage创建完成后会进入`onWindowStageCreate()`回调，可以**在该回调中设置UI加载、设置WindowStage的事件订阅**。

**图2** WindowStageCreate和WindowStageDestroy状态
![Ability-Life-Cycle-WindowStage](./开发者文档——开发.assets/Ability-Life-Cycle-WindowStage.png)

在onWindowStageCreate()回调中通过[`loadContent()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-window.md#loadcontent9-2)方法设置应用要加载的页面，并根据需要调用[`on('windowStageEvent')`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-window.md#onwindowstageevent9)方法订阅WindowStage的[事件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-window.md#windowstageeventtype9)（获焦/失焦、可见/不可见）。

```ts
import UIAbility from '@ohos.app.ability.UIAbility';
import window from '@ohos.window';

export default class EntryAbility extends UIAbility {
  // ...

  onWindowStageCreate(windowStage: window.WindowStage) {
    // 设置WindowStage的事件订阅（获焦/失焦、可见/不可见）
    try {
      windowStage.on('windowStageEvent', (data) => {
        let stageEventType: window.WindowStageEventType = data;
        switch (stageEventType) {
          case window.WindowStageEventType.SHOWN: // 切到前台
            console.info('windowStage foreground.');
            break;
          case window.WindowStageEventType.ACTIVE: // 获焦状态
            console.info('windowStage active.');
            break;
          case window.WindowStageEventType.INACTIVE: // 失焦状态
            console.info('windowStage inactive.');
            break;
          case window.WindowStageEventType.HIDDEN: // 切到后台
            console.info('windowStage background.');
            break;
          default:
            break;
        }
      });
    } catch (exception) {
      console.error('Failed to enable the listener for window stage event changes. Cause:' +
      JSON.stringify(exception));
    }

    // 设置UI加载
    windowStage.loadContent('pages/Index', (err, data) => {
      // ...
    });
  }
}
ts
```

> **说明：**
>
> WindowStage的相关使用请参见[窗口开发指导](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/windowmanager/application-window-stage.md)。

对应于`onWindowStageCreate()`回调。在UIAbility实例销毁之前，则会先进入`onWindowStageDestroy()`回调，可以在该回调中释放UI资源。例如在`onWindowStageDestroy()`中注销获焦/失焦等WindowStage事件。

```ts
import UIAbility from '@ohos.app.ability.UIAbility';
import window from '@ohos.window';
import { BusinessError } from '@ohos.base';

export default class EntryAbility extends UIAbility {
  windowStage: window.WindowStage | undefined = undefined;
  // ...

  onWindowStageCreate(windowStage: window.WindowStage) {
    this.windowStage = windowStage;
    // ...
  }

  onWindowStageDestroy() {
    // 释放UI资源
    // 例如在onWindowStageDestroy()中注销获焦/失焦等WindowStage事件
    try {
      if (this.windowStage) {
        this.windowStage.off('windowStageEvent');
      }
    } catch (err) {
      let code = (err as BusinessError).code;
      let message = (err as BusinessError).message;
      console.error(`Failed to disable the listener for windowStageEvent. Code is ${code}, message is ${message}`);
    };
  }
}
ts
```

##### Foreground和Background状态

Foreground和Background状态分别在UIAbility实例切换至前台和切换至后台时触发，对应于`onForeground()`回调和`onBackground()`回调。

`onForeground()`回调，在UIAbility的UI可见之前，如UIAbility切换至前台时触发。可以在`onForeground()`回调中**申请系统需要的资源**，或者**重新申请在**`onBackground()`**中释放的资源**。

`onBackground()`回调，在UIAbility的UI完全不可见之后，如UIAbility切换至后台时候触发。可以在`onBackground()`回调中**释放UI不可见时无用的资源**，或者在此回调中**执行较为耗时的操作**，例如**状态保存**等。

例如应用在使用过程中需要使用用户定位时，假设应用已获得用户的定位权限授权。在UI显示之前，可以在`onForeground()`回调中开启定位功能，从而获取到当前的位置信息。

当应用切换到后台状态，可以在`onBackground()`回调中停止定位功能，以节省系统的资源消耗。

```ts
import UIAbility from '@ohos.app.ability.UIAbility';

export default class EntryAbility extends UIAbility {
  // ...

  onForeground() {
    // 申请系统需要的资源，或者重新申请在onBackground()中释放的资源
  }

  onBackground() {
    // 释放UI不可见时无用的资源，或者在此回调中执行较为耗时的操作
    // 例如状态保存等
  }
}
ts
```

##### Destroy状态

Destroy状态在UIAbility实例销毁时触发。可以在onDestroy()回调中进行系统资源的释放、数据的保存等操作。

例如调用`terminateSelf()`方法停止当前UIAbility实例，从而完成UIAbility实例的销毁；或者用户使用最近任务列表关闭该UIAbility实例，完成UIAbility的销毁。

```ts
import UIAbility from '@ohos.app.ability.UIAbility';

export default class EntryAbility extends UIAbility {
  // ...

  onDestroy() {
    // 系统资源的释放、数据的保存等
  }
}
ts
```

#### 相关实例

针对UIAbility生命周期，有以下相关实例可供参考：

- [UIAbility和自定义组件生命周期（ArkTS）（API9）](https://gitee.com/openharmony/codelabs/tree/master/Ability/UIAbilityLifeCycle)



### UIAbility组件启动模式

UIAbility的启动模式是指UIAbility实例在启动时的不同呈现状态。针对不同的业务场景，系统提供了三种启动模式：

- [singleton（单实例模式）](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-launch-type.md#singleton启动模式)
- [multiton（多实例模式）](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-launch-type.md#multiton启动模式)
- [specified（指定实例模式）](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-launch-type.md#specified启动模式)

#### singleton启动模式

singleton启动模式为单实例模式，也是默认情况下的启动模式。

每次调用[`startAbility()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextstartability)方法时，如果应用进程中该类型的UIAbility实例**已经存在，则复用**系统中的UIAbility实例。系统中只存在唯一一个该UIAbility实例，即在最近任务列表中只存在一个该类型的UIAbility实例。

**图1** 单实例模式演示效果
![uiability-launch-type1](./开发者文档——开发.assets/uiability-launch-type1.gif)

> **说明**：
>
> 应用的UIAbility实例已创建，该UIAbility配置为单实例模式，再次调用[`startAbility()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextstartability)方法启动该UIAbility实例。由于启动的还是原来的UIAbility实例，并未重新创建一个新的UIAbility实例，此时**只会进入该UIAbility的[`onNewWant()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#uiabilityonnewwant)回调**，不会进入其[`onCreate()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#uiabilityoncreate)和[`onWindowStageCreate()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#uiabilityonwindowstagecreate)生命周期回调。

如果需要使用singleton启动模式，在[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)中的`launchType`字段配置为`singleton`即可。

```json
{
  "module": {
    ...
    "abilities": [
      {
        "launchType": "singleton",
        ...
      }
    ]
  }
}
json
```

#### multiton启动模式

multiton启动模式为多实例模式，每次调用[`startAbility()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextstartability)方法时，都会在应用进程中**创建一个新的**该类型UIAbility实例。即在最近任务列表中可以看到有多个该类型的UIAbility实例。这种情况下可以将UIAbility配置为multiton（多实例模式）。

**图2** 多实例模式演示效果
![uiability-launch-type2](./开发者文档——开发.assets/uiability-launch-type2.gif)

multiton启动模式的开发使用，在[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)中的`launchType`字段配置为`multiton`即可。

```json
{
  "module": {
    ...
    "abilities": [
      {
        "launchType": "multiton",
        ...
      }
    ]
  }
}
json
```

#### specified启动模式

specified启动模式为**指定实例模式**，针对一些**特殊场景**使用（例如文档应用中每次新建文档希望都能新建一个文档实例，重复打开一个已保存的文档希望打开的都是同一个文档实例）。

**图3** 指定实例模式演示效果
![uiability-launch-type3](./开发者文档——开发.assets/uiability-launch-type3.gif)

例如有两个UIAbility：EntryAbility和SpecifiedAbility，SpecifiedAbility配置为指定实例模式启动，需要从EntryAbility的页面中启动SpecifiedAbility。

1. 在SpecifiedAbility中，将[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)的`launchType`字段配置为`specified`。

   ```
   {
     "module": {
       ...
       "abilities": [
         {
           "launchType": "specified",
           ...
         }
       ]
     }
   }
   json
   ```

2. 在**创建UIAbility实例之前，开发者可以为该实例指定一个唯一的字符串Key**，这样在调用[`startAbility()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextstartability)方法时，应用就可以**根据指定的Key**来识别响应请求的UIAbility实例。在EntryAbility中，**调用[`startAbility()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextstartability)方法时，可以在`want`参数中增加一个自定义参数**，例如`instanceKey`，以此来区分不同的UIAbility实例。

   ```ts
   // 在启动指定实例模式的UIAbility时，给每一个UIAbility实例配置一个独立的Key标识
   // 例如在文档使用场景中，可以用文档路径作为Key标识
   import common from '@ohos.app.ability.common';
   import Want from '@ohos.app.ability.Want';
   import { BusinessError } from '@ohos.base';
   
   function getInstance() {
     return 'key';
   }
   
   let context:common.UIAbilityContext = ...; // context为调用方UIAbility的UIAbilityContext
   let want: Want = {
     deviceId: '', // deviceId为空表示本设备
     bundleName: 'com.example.myapplication',
     abilityName: 'SpecifiedAbility',
     moduleName: 'specified', // moduleName非必选
     parameters: { // 自定义信息
       instanceKey: getInstance(),
     },
   }
   
   context.startAbility(want).then(() => {
     console.info('Succeeded in starting ability.');
   }).catch((err: BusinessError) => {
     console.error(`Failed to start ability. Code is ${err.code}, message is ${err.message}`);
   })
   ts
   ```

3. 由于SpecifiedAbility的启动模式**被配置为指定实例启动模式**，因此在SpecifiedAbility启动之前，**会先进入对应的`AbilityStage`的[`onAcceptWant()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-abilityStage.md#abilitystageonacceptwant)生命周期回调中**，以获取该UIAbility实例的Key值。然后系统会**自动匹配**，如果存在与该UIAbility实例匹配的Key，则会启动与之绑定的UIAbility实例，并进入该UIAbility实例的[`onNewWant()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#abilityonnewwant)回调函数；否则会创建一个新的UIAbility实例，并进入该UIAbility实例的[`onCreate()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#uiabilityoncreate)回调函数和[`onWindowStageCreate()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#uiabilityonwindowstagecreate)回调函数。

   示例代码中，通过实现[`onAcceptWant()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-abilityStage.md#abilitystageonacceptwant)生命周期回调函数，解析传入的`want`参数，获取自定义参数`instanceKey`。业务逻辑会根据这个参数返回一个字符串Key，用于标识当前UIAbility实例。如果返回的Key已经对应一个已启动的UIAbility实例，系统会将该UIAbility实例拉回前台并获焦，而不会创建新的实例。如果返回的Key没有对应已启动的UIAbility实例，则系统会创建新的UIAbility实例并启动。

   ```ts
   import AbilityStage from '@ohos.app.ability.AbilityStage';
   import Want from '@ohos.app.ability.Want';
   
   export default class MyAbilityStage extends AbilityStage {
     onAcceptWant(want: Want): string {
       // 在被调用方的AbilityStage中，针对启动模式为specified的UIAbility返回一个UIAbility实例对应的一个Key值
       // 当前示例指的是module1 Module的SpecifiedAbility
       if (want.abilityName === 'SpecifiedAbility') {
         // 返回的字符串Key标识为自定义拼接的字符串内容
         if (want.parameters) {
           return `SpecifiedAbilityInstance_${want.parameters.instanceKey}`;
         }
       }
   
       return '';
     }
   }
   ts
   ```

   > **说明：**
   >
   > 1. 当应用的UIAbility实例已经被创建，并且配置为指定实例模式时，如果再次调用[`startAbility()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextstartability)方法启动该UIAbility实例，且[AbilityStage](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-abilityStage.md)的[`onAcceptWant()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-abilityStage.md#abilitystageonacceptwant)回调匹配到一个已创建的UIAbility实例，则系统会启动原来的UIAbility实例，并且不会重新创建一个新的UIAbility实例。此时，该UIAbility实例的[`onNewWant()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#abilityonnewwant)回调会被触发，而不会触发[`onCreate()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#uiabilityoncreate)和[`onWindowStageCreate()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#uiabilityonwindowstagecreate)生命周期回调。
   > 2. DevEco Studio默认工程中未自动生成AbilityStage，AbilityStage文件的创建请参见[AbilityStage组件容器](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/abilitystage.md)。

   例如在文档应用中，可以为不同的文档实例内容绑定不同的Key值。每次新建文档时，可以传入一个新的Key值（例如可以将文件的路径作为一个Key标识），此时AbilityStage中启动UIAbility时都会创建一个新的UIAbility实例；当新建的文档保存之后，回到桌面，或者新打开一个已保存的文档，回到桌面，此时再次打开该已保存的文档，此时AbilityStage中再次启动该UIAbility时，打开的仍然是之前原来已保存的文档界面。

   以如下步骤所示进行举例说明。

   1. 打开`文件A`，对应启动一个新的UIAbility实例，例如启动`UIAbility实例1`。
   2. 在最近任务列表中关闭`文件A`的任务进程，此时`UIAbility实例1`被销毁，回到桌面，再次打开`文件A`，此时对应启动一个新的UIAbility实例，例如启动`UIAbility实例2`。
   3. 回到桌面，打开`文件B`，此时对应启动一个新的UIAbility实例，例如启动`UIAbility实例3`。
   4. 回到桌面，再次打开`文件A`，此时仍然启动之前的`UIAbility实例2`，因为系统会自动匹配UIAbility实例的Key值，如果存在与之匹配的Key，则会启动与之绑定的UIAbility实例。在此例中，之前启动的`UIAbility实例2`与`文件A`绑定的Key是相同的，因此系统会拉回`UIAbility实例2`并让其获焦，而不会创建新的实例。

#### 相关实例

针对UIAbility组件启动模式，有以下相关实例可供参考：

- [Ability的启动模式（ArkTS）(API9)](https://gitee.com/openharmony/applications_app_samples/tree/OpenHarmony-4.0-Release/code/BasicFeature/ApplicationModels/AbilityStartMode)



### UIAbility组件基本用法

UIAbility组件的基本用法包括：指定UIAbility的启动页面以及获取UIAbility的上下文[UIAbilityContext](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md)。

#### 指定UIAbility的启动页面

应用中的UIAbility在启动过程中，需要指定启动页面，否则应用启动后会因为没有默认加载页面而导致白屏。可以在UIAbility的`onWindowStageCreate()`生命周期回调中，通过[WindowStage](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-window.md#windowstage9)对象的`loadContent()`方法设置启动页面。

```ts
import UIAbility from '@ohos.app.ability.UIAbility';
import window from '@ohos.window';

export default class EntryAbility extends UIAbility {
  onWindowStageCreate(windowStage: window.WindowStage) {
    // Main window is created, set main page for this ability
    windowStage.loadContent('pages/Index', (err, data) => {
      // ...
    });
  }

  // ...
}
```

> **说明：** 在DevEco Studio中创建的UIAbility中，该UIAbility实例默认会加载Index页面，根据需要将Index页面路径替换为需要的页面路径即可。



#### 获取UIAbility的上下文信息

UIAbility类拥有自身的上下文信息，该信息为[UIAbilityContext](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md)类的实例，[UIAbilityContext](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md)类拥有abilityInfo、currentHapModuleInfo等属性。通过UIAbilityContext可以获取UIAbility的相关配置信息，如包代码路径、Bundle名称、Ability名称和应用程序需要的环境状态等属性信息，以及可以获取操作UIAbility实例的方法（如`startAbility()`、`connectServiceExtensionAbility()`、`terminateSelf()`等）。 如果需要在页面中获得当前Ability的Context，可调用[getContext](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-getContext.md#getcontext)接口获取当前页面关联的UIAbilityContext或ExtensionContext。

- 在UIAbility中可以通过`this.context`获取UIAbility实例的上下文信息。

  ```ts
  import UIAbility from '@ohos.app.ability.UIAbility';
  import AbilityConstant from '@ohos.app.ability.AbilityConstant';
  import Want from '@ohos.app.ability.Want';
  
  export default class EntryAbility extends UIAbility {
    onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
      // 获取UIAbility实例的上下文
      let context = this.context;
      ...
    }
  }
  ```

- 在页面中获取UIAbility实例的上下文信息，包括导入依赖资源context模块和在组件中定义一个context变量两个部分。

  ```ts
  import common from '@ohos.app.ability.common';
  import Want from '@ohos.app.ability.Want';
  
  @Entry
  @Component
  struct Index {
    private context = getContext(this) as common.UIAbilityContext;
  
    startAbilityTest() {
      let want: Want = {
        // Want参数信息
      };
      this.context.startAbility(want);
    }
  
    // 页面展示
    build() {
      ...
    }
  }
  ts
  ```

  也可以在导入依赖资源context模块后，在具体使用[UIAbilityContext](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md)前进行变量定义。

  ```ts
  import common from '@ohos.app.ability.common';
  import Want from '@ohos.app.ability.Want';
  
  @Entry
  @Component
  struct Index {
  
    startAbilityTest() {
      let context = getContext(this) as common.UIAbilityContext;
      let want: Want = {
        // Want参数信息
      };
      context.startAbility(want);
    }
  
    // 页面展示
    build() {
      ...
    }
  }
  ```



### UIAbility组件与UI的数据同步

基于当前的应用模型，可以通过以下几种方式来实现UIAbility组件与UI之间的数据同步。

- [使用EventHub进行数据通信](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-data-sync-with-ui.md#使用eventhub进行数据通信)：在**基类Context中提供了`EventHub`对象**，可以**通过发布订阅方式来实现事件的传递**。在事件传递前，订阅者需要先进行订阅，当发布者发布事件时，订阅者将接收到事件并进行相应处理。
- [使用AppStorage/LocalStorage进行数据同步](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-data-sync-with-ui.md#使用appstoragelocalstorage进行数据同步)：ArkUI**提供了AppStorage和LocalStorage两种应用级别的状态管理方案**，可用于实现**应用级别和UIAbility级别的数据同步**。

#### 使用EventHub进行数据通信

[EventHub](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-eventHub.md)为UIAbility组件提供了事件机制，使它们能够进行**订阅、取消订阅和触发事件等数据通信能力**。

在[基类Context](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/application-context-stage.md)中，**提供了EventHub对象，可用于在UIAbility组件实例内通信**。使用EventHub实现UIAbility与UI之间的数据通信需要先获取EventHub对象，本章节将以此为例进行说明。

1. 在UIAbility中**调用[`eventHub.on()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-eventHub.md#eventhubon)方法注册**一个自定义事件“event1”，[`eventHub.on()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-eventHub.md#eventhubon)有如下两种调用方式，使用其中一种即可。

   ```ts
   import UIAbility from '@ohos.app.ability.UIAbility';
   import AbilityConstant from '@ohos.app.ability.AbilityConstant';
   import Want from '@ohos.app.ability.Want';
   
   const TAG: string = '[Example].[Entry].[EntryAbility]';
   
   export default class EntryAbility extends UIAbility {
     func1(data: string) {
       // 触发事件，完成相应的业务操作
       console.info(TAG, '1. ' + JSON.stringify(data));
     }
   
     onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
       // 获取eventHub
       let eventhub = this.context.eventHub;
       // 执行订阅操作
       eventhub.on('event1', this.func1);
       eventhub.on('event1', (data: string) => {
         // 触发事件，完成相应的业务操作
         console.info(TAG, '2. ' + JSON.stringify(data));
       });
     }
   }
   ```

2. 在UI中**通过[eventHub.emit()](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-eventHub.md#eventhubemit)方法触发该事件**，在触发事件的同时，根据需要传入参数信息。

   ```ts
   import common from '@ohos.app.ability.common';
   
   @Entry
   @Component
   struct Index {
     private context = getContext(this) as common.UIAbilityContext;
   
     eventHubFunc() {
       // 不带参数触发自定义“event1”事件
       this.context.eventHub.emit('event1');
       // 带1个参数触发自定义“event1”事件
       this.context.eventHub.emit('event1', 1);
       // 带2个参数触发自定义“event1”事件
       this.context.eventHub.emit('event1', 2, 'test');
       // 开发者可以根据实际的业务场景设计事件传递的参数
     }
   
     // 页面展示
     build() {
       Column() {
         Button('按钮')
           .onClick(() => {
             this.eventHubFunc();
         })
         Button('关闭')
           .onClick(() => {
             this.context.eventHub.off('event1');
         })
       }
     }
   }
   ts
   ```

3. 在UIAbility的注册事件回调中可以得到对应的触发事件结果，运行日志结果如下所示。

   ```ts
   [Example].[Entry].[EntryAbility] 1. []
   [Example].[Entry].[EntryAbility] 2. []
   [Example].[Entry].[EntryAbility] 1. [1]
   [Example].[Entry].[EntryAbility] 2. [1]
   [Example].[Entry].[EntryAbility] 1. [2,"test"]
   [Example].[Entry].[EntryAbility] 2. [2,"test"]
   json
   ```

4. 在自定义事件“event1”使用完成后，可以根据需要**调用[eventHub.off()](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-eventHub.md#eventhuboff)方法取消该事件的订阅**。

   ```ts
   // context为UIAbility实例的AbilityContext
   this.context.eventHub.off('event1');
   ts
   ```

#### 使用AppStorage/LocalStorage进行数据同步

ArkUI提供了AppStorage和LocalStorage两种应用级别的状态管理方案，可用于实现应用级别和UIAbility级别的数据同步。使用这些方案可以方便地管理应用状态，提高应用性能和用户体验。其中，AppStorage是一个全局的状态管理器，适用于多个UIAbility共享同一状态数据的情况；而LocalStorage则是一个局部的状态管理器，适用于单个UIAbility内部使用的状态数据。通过这两种方案，开发者可以更加灵活地控制应用状态，提高应用的可维护性和可扩展性。详细请参见[应用级变量的状态管理](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/arkts-application-state-management-overview.md)。



### UIAbility组件间交互（设备内）

UIAbility是系统调度的最小单元。在设备内的功能模块之间跳转时，会涉及到启动特定的UIAbility，该UIAbility可以是应用内的其他UIAbility，也可以是其他应用的UIAbility（例如启动三方支付UIAbility）。

本文将从如下场景分别介绍设备内UIAbility间的交互方式。对于跨设备的应用组件交互，请参见[应用组件跨设备交互（流转）](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/inter-device-interaction-hop-overview.md)。

- [启动应用内的UIAbility](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-intra-device-interaction.md#启动应用内的uiability)
- [启动应用内的UIAbility并获取返回结果](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-intra-device-interaction.md#启动应用内的uiability并获取返回结果)
- [启动其他应用的UIAbility](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-intra-device-interaction.md#启动其他应用的uiability)
- [启动其他应用的UIAbility并获取返回结果](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-intra-device-interaction.md#启动其他应用的uiability并获取返回结果)
- [启动UIAbility指定窗口模式（仅对系统应用开放）](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-intra-device-interaction.md#启动uiability指定窗口模式仅对系统应用开放)
- [启动UIAbility的指定页面](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-intra-device-interaction.md#启动uiability的指定页面)
- [通过Call调用实现UIAbility交互（仅对系统应用开放）](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-intra-device-interaction.md#通过call调用实现uiability交互仅对系统应用开放)

#### 启动应用内的UIAbility

当一个应用内包含多个UIAbility时，存在应用内启动UIAbility的场景。例如在支付应用中从入口UIAbility启动收付款UIAbility。

假设应用中有两个UIAbility：EntryAbility和FuncAbility（可以在同一个Module中，也可以在不同的Module中），需要从EntryAbility的页面中启动FuncAbility。

1. 在EntryAbility中，通过调用[`startAbility()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextstartability)方法启动UIAbility，[want](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-want.md)为UIAbility实例启动的入口参数，其中bundleName为待启动应用的Bundle名称，abilityName为待启动的Ability名称，moduleName在待启动的UIAbility属于不同的Module时添加，parameters为自定义信息参数。示例中的context的获取方式请参见[获取UIAbility的上下文信息](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-usage.md#获取uiability的上下文信息)。

   ```ts
   import common from '@ohos.app.ability.common';
   import Want from '@ohos.app.ability.Want';
   import { BusinessError } from '@ohos.base';
   
   let context: common.UIAbilityContext = ...; // UIAbilityContext
   let want: Want = {
     deviceId: '', // deviceId为空表示本设备
     bundleName: 'com.example.myapplication',
     moduleName: 'func', // moduleName非必选
     abilityName: 'FuncAbility',
     parameters: { // 自定义信息
       info: '来自EntryAbility Index页面',
     },
   }
   // context为调用方UIAbility的UIAbilityContext
   context.startAbility(want).then(() => {
     console.info('Succeeded in starting ability.');
   }).catch((err: BusinessError) => {
     console.error(`Failed to start ability. Code is ${err.code}, message is ${err.message}`);
   })
   ```

2. 在FuncAbility的[`onCreate()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#uiabilityoncreate)或者[`onNewWant()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#uiabilityonnewwant)生命周期回调文件中接收EntryAbility传递过来的参数。

   ```ts
   import UIAbility from '@ohos.app.ability.UIAbility';
   import AbilityConstant from '@ohos.app.ability.AbilityConstant';
   import Want from '@ohos.app.ability.Want';
   
   export default class FuncAbility extends UIAbility {
     onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
       // 接收调用方UIAbility传过来的参数
       let funcAbilityWant = want;
       let info = funcAbilityWant?.parameters?.info;
       // ...
     }
   }
   ts
   ```

   > **说明：**
   >
   > 在**被拉起的FuncAbility中**，可以通过获取传递过来的`want`参数的`parameters`来**获取拉起方UIAbility的PID、Bundle Name等信息**。

3. 在FuncAbility业务完成之后，如需要停止当前UIAbility实例，在FuncAbility中通过调用[`terminateSelf()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextterminateself)方法实现。

   ```ts
   import common from '@ohos.app.ability.common';
   
   let context: common.UIAbilityContext = ...; // UIAbilityContext
   
   // context为需要停止的UIAbility实例的AbilityContext
   context.terminateSelf((err) => {
     if (err.code) {
       console.error(`Failed to terminate Self. Code is ${err.code}, message is ${err.message}`);
       return;
     }
   });
   ```

   > **说明：**
   >
   > 调用[`terminateSelf()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextterminateself)方法停止当前UIAbility实例时，**默认会保留该实例的快照**（Snapshot），即在最近任务列表中仍然能查看到该实例对应的任务。**如不需要保留该实例的快照**，可以在其对应UIAbility的[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)中，将[abilities标签](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md#abilities标签)的
   >
   > `removeMissionAfterTerminate`字段配置为`true`。

4. 如需要**关闭应用所有的UIAbility实例**，可以调用[ApplicationContext](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-applicationContext.md)的[`killAllProcesses()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-applicationContext.md#applicationcontextkillallprocesses)方法实现关闭应用所有的进程。

#### 启动应用内的UIAbility并获取返回结果

在一个EntryAbility启动另外一个FuncAbility时，希望在被启动的FuncAbility完成相关业务后，能将结果返回给调用方。例如在应用中将入口功能和帐号登录功能分别设计为两个独立的UIAbility，在帐号登录UIAbility中完成登录操作后，需要将登录的结果返回给入口UIAbility。

1. 在EntryAbility中，调用[`startAbilityForResult()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextterminateselfwithresult)接口启动FuncAbility，异步回调中的data用于接收FuncAbility停止自身后返回给EntryAbility的信息。示例中的context的获取方式请参见[获取UIAbility的上下文信息](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-usage.md#获取uiability的上下文信息)。

   ```ts
   import common from '@ohos.app.ability.common';
   import Want from '@ohos.app.ability.Want';
   import { BusinessError } from '@ohos.base';
   
   let context: common.UIAbilityContext = ...; // UIAbilityContext
   let want: Want = {
     deviceId: '', // deviceId为空表示本设备
     bundleName: 'com.example.myapplication',
     moduleName: 'func', // moduleName非必选
     abilityName: 'FuncAbility',
     parameters: { // 自定义信息
       info: '来自EntryAbility Index页面',
     },
   }
   // context为调用方UIAbility的UIAbilityContext
   context.startAbilityForResult(want).then((data) => {
     // ...
   }).catch((err: BusinessError) => {
     console.error(`Failed to start ability for result. Code is ${err.code}, message is ${err.message}`);
   })
   ```

2. 在FuncAbility停止自身时，需要调用[`terminateSelfWithResult()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextterminateselfwithresult)方法，入参abilityResult为FuncAbility需要返回给EntryAbility的信息。

   ```ts
   import common from '@ohos.app.ability.common';
   import Want from '@ohos.app.ability.Want';
   
   let context: common.UIAbilityContext = ...; // UIAbilityContext
   const RESULT_CODE: number = 1001;
   let abilityResult: common.AbilityResult = {
     resultCode: RESULT_CODE,
     want: {
       bundleName: 'com.example.myapplication',
       moduleName: 'func', // moduleName非必选
       abilityName: 'FuncAbility',
       parameters: {
         info: '来自FuncAbility Index页面',
       },
     },
   }
   // context为被调用方UIAbility的AbilityContext
   context.terminateSelfWithResult(abilityResult, (err) => {
     if (err.code) {
       console.error(`Failed to terminate self with result. Code is ${err.code}, message is ${err.message}`);
       return;
     }
   });
   ```

3. FuncAbility停止自身后，EntryAbility通过[`startAbilityForResult()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextterminateselfwithresult)方法回调接收被FuncAbility返回的信息，RESULT_CODE需要与前面的数值保持一致。

   ```ts
   import common from '@ohos.app.ability.common';
   import Want from '@ohos.app.ability.Want';
   import { BusinessError } from '@ohos.base';
   
   let context: common.UIAbilityContext = ...; // UIAbilityContext
   const RESULT_CODE: number = 1001;
   
   let want: Want = {
     deviceId: '', // deviceId为空表示本设备
     bundleName: 'com.example.myapplication',
     moduleName: 'func', // moduleName非必选
     abilityName: 'FuncAbility',
   }
   
   // context为调用方UIAbility的UIAbilityContext
   context.startAbilityForResult(want).then((data) => {
     if (data?.resultCode === RESULT_CODE) {
       // 解析被调用方UIAbility返回的信息
       let info = data.want?.parameters?.info;
       // ...
     }
   }).catch((err: BusinessError) => {
     console.error(`Failed to start ability for result. Code is ${err.code}, message is ${err.message}`);
   })
   ```

#### 启动其他应用的UIAbility

启动其他应用的UIAbility，**通常用户只需要完成一个通用的操作**（例如需要选择一个文档应用来查看某个文档的内容信息），推荐使用[隐式Want启动](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/want-overview.md#want的类型)。系统会根据调用方的want参数来识别和启动匹配到的应用UIAbility。

启动UIAbility有[显式Want启动和隐式Want启动](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/want-overview.md)两种方式。

- **显式`Want`启动**：启动一个确定应用的UIAbility，**在want参数中需要设置该应用bundleName和abilityName**，当需要拉起某个明确的UIAbility时，通常使用显式Want启动方式。
- **隐式`Want`启动**：根据匹配条件由用户选择启动哪一个UIAbility，即不明确指出要启动哪一个UIAbility（**abilityName参数未设置**），在调用[`startAbility()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextstartability)方法时，其**入参want中指定了一系列的`entities`字段**（表示目标UIAbility额外的类别信息，如浏览器、视频播放器）和**`actions`字段**（表示要执行的通用操作，如查看、分享、应用详情等）等参数信息，然后由系统去分析want，并帮助找到合适的UIAbility来启动。当需要拉起其他应用的UIAbility时，开发者通常不知道用户设备中应用的安装情况，也无法确定目标应用的bundleName和abilityName，通常使用隐式Want启动方式。

本文主要讲解如何通过隐式Want启动其他应用的UIAbility。

1. 将多个待匹配的文档应用安装到设备，在其对应UIAbility的[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)中，配置skills标签的entities字段和actions字段。

   ```json
   {
     "module": {
       "abilities": [
         {
           ...
           "skills": [
             {
               "entities": [
                 ...
                 "entity.system.default"
               ],
               "actions": [
                 ...
                 "ohos.want.action.viewData"
               ]
             }
           ]
         }
       ]
     }
   }
   ```

2. 在调用方want参数中的entities和action需要被包含在待匹配UIAbility的skills配置的entities和actions中。系统匹配到符合entities和actions参数条件的UIAbility后，会弹出选择框展示匹配到的UIAbility实例列表供用户选择使用。示例中的context的获取方式请参见[获取UIAbility的上下文信息](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-usage.md#获取uiability的上下文信息)。

   ```ts
   import common from '@ohos.app.ability.common';
   import Want from '@ohos.app.ability.Want';
   import { BusinessError } from '@ohos.base';
   
   let context: common.UIAbilityContext = ...; // UIAbilityContext
   let want: Want = {
     deviceId: '', // deviceId为空表示本设备
     // 如果希望隐式仅在特定的捆绑包中进行查询，请取消下面的注释。
     // bundleName: 'com.example.myapplication',
     action: 'ohos.want.action.viewData',
     // entities可以被省略
     entities: ['entity.system.default'],
   }
   
   // context为调用方UIAbility的UIAbilityContext
   context.startAbility(want).then(() => {
     console.info('Succeeded in starting ability.');
   }).catch((err: BusinessError) => {
     console.error(`Failed to start ability. Code is ${err.code}, message is ${err.message}`);
   })
   ```

   效果示意如下图所示，点击“打开PDF文档”时，会弹出选择框供用户选择。
   ![img](./开发者文档——开发.assets/uiability-intra-device-interaction.png)

3. 在文档应用使用完成之后，如需要停止当前UIAbility实例，通过调用[`terminateSelf()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextterminateself)方法实现。

   ```ts
   import common from '@ohos.app.ability.common';
   
   let context: common.UIAbilityContext = ...; // UIAbilityContext
   
   // context为需要停止的UIAbility实例的AbilityContext
   context.terminateSelf((err) => {
     if (err.code) {
       console.error(`Failed to terminate self. Code is ${err.code}, message is ${err.message}`);
       return;
     }
   });
   ```

#### 启动其他应用的UIAbility并获取返回结果

当使用隐式Want启动其他应用的UIAbility并希望获取返回结果时，调用方需要使用[`startAbilityForResult()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextterminateselfwithresult)方法启动目标UIAbility。例如主应用中需要启动三方支付并获取支付结果。

1. 在支付应用对应UIAbility的[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)中，配置skills的entities字段和actions字段。

   ```json
   {
     "module": {
       "abilities": [
         {
           ...
           "skills": [
             {
               "entities": [
                 ...
                 "entity.system.default"
               ],
               "actions": [
                 ...
                 "ohos.want.action.editData"
               ]
             }
           ]
         }
       ]
     }
   }
   ```

2. 调用方使用[`startAbilityForResult()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextterminateselfwithresult)方法启动支付应用的UIAbility，在调用方want参数中的entities和action需要被包含在待匹配UIAbility的skills标签配置的entities和actions中。异步回调中的data用于后续接收支付UIAbility停止自身后返回给调用方的信息。系统匹配到符合entities和actions参数条件的UIAbility后，会弹出选择框展示匹配到的UIAbility实例列表供用户选择使用。

   ```ts
   import common from '@ohos.app.ability.common';
   import Want from '@ohos.app.ability.Want';
   import { BusinessError } from '@ohos.base';
   
   let context: common.UIAbilityContext = this.context; // UIAbilityContext
   let want: Want = {
     deviceId: '', // deviceId为空表示本设备
     // uncomment line below if wish to implicitly query only in the specific bundle.
     // bundleName: 'com.example.myapplication',
     action: 'ohos.want.action.editData',
     // entities can be omitted.
     entities: ['entity.system.default']
   }
   
   // context为调用方UIAbility的UIAbilityContext
   context.startAbilityForResult(want).then((data) => {
     // ...
   }).catch((err: BusinessError) => {
     console.error(`Failed to start ability for result. Code is ${err.code}, message is ${err.message}`);
   })
   ```

3. 在支付UIAbility完成支付之后，需要调用[`terminateSelfWithResult()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextterminateselfwithresult)方法实现停止自身，并将abilityResult参数信息返回给调用方。

   ```ts
   import common from '@ohos.app.ability.common';
   import Want from '@ohos.app.ability.Want';
   
   let context: common.UIAbilityContext = ...; // UIAbilityContext
   const RESULT_CODE: number = 1001;
   let abilityResult: common.AbilityResult = {
     resultCode: RESULT_CODE,
     want: {
       bundleName: 'com.example.funcapplication',
       moduleName: 'entry', // moduleName非必选
       abilityName: 'EntryAbility',
       parameters: {
         payResult: 'OKay',
       },
     },
   }
   // context为被调用方UIAbility的AbilityContext
   context.terminateSelfWithResult(abilityResult, (err) => {
     if (err.code) {
       console.error(`Failed to terminate self with result. Code is ${err.code}, message is ${err.message}`);
       return;
     }
   });
   ```

4. 在调用方[`startAbilityForResult()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextterminateselfwithresult)方法回调中接收支付应用返回的信息，RESULT_CODE需要与前面[`terminateSelfWithResult()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextterminateselfwithresult)返回的数值保持一致。

   ```ts
   import common from '@ohos.app.ability.common';
   import Want from '@ohos.app.ability.Want';
   import { BusinessError } from '@ohos.base';
   
   let context: common.UIAbilityContext = ...; // UIAbilityContext
   const RESULT_CODE: number = 1001;
   
   let want: Want = {
     // Want参数信息
   };
   
   // context为调用方UIAbility的UIAbilityContext
   context.startAbilityForResult(want).then((data) => {
     if (data?.resultCode === RESULT_CODE) {
       // 解析被调用方UIAbility返回的信息
       let payResult = data.want?.parameters?.payResult;
       // ...
     }
   }).catch((err: BusinessError) => {
     console.error(`Failed to start ability for result. Code is ${err.code}, message is ${err.message}`);
   })
   ```

#### 启动UIAbility指定窗口模式（仅对系统应用开放）

当用户打开应用时，应用程序会以不同的窗口模式进行展示，即启动UIAbility的窗口模式。应用程序可以启动为全屏模式，悬浮窗模式或分屏模式。

全屏模式是指应用程序启动后，占据整个屏幕，用户无法同时查看其他窗口或应用程序。全屏模式通常适用于那些要求用户专注于特定任务或界面的应用程序。

悬浮窗模式是指应用程序启动后，以浮动窗口的形式显示在屏幕上，用户可以轻松切换到其他窗口或应用程序。悬浮窗通常适用于需要用户同时处理多个任务的应用程序。

分屏模式允许用户在同一屏幕上同时运行两个应用程序，其中一个应用程序占据屏幕左侧/上侧的一部分，另一个应用程序占据右侧/下侧的一部分。分屏模式主要用于提高用户的多任务处理效率。

使用[`startAbility()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextstartability)方法启动UIAbility时，可以通过在入参中增加[StartOptions](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-startOptions.md)参数的windowMode属性来配置启动UIAbility的窗口模式。

> **说明：**
>
> 1. 如果在使用[`startAbility()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextstartability)方法启动UIAbility时，入参中未指定[StartOptions](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-startOptions.md)参数的windowMode属性，那么UIAbility将以系统默认的窗口展示形态启动。
> 2. 为了确保启动的UIAbility展示形态能够被支持，需要在该UIAbility对应的[module.json5配置文件](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md)中[abilities标签](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/quick-start/module-configuration-file.md#abilities标签)的supportWindowMode字段确认启动的展示形态被支持。

以下是具体的操作步骤，以悬浮窗模式为例，假设需要从EntryAbility的页面中启动FuncAbility：

1. 在调用[`startAbility()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#uiabilitycontextstartability)方法时，增加[StartOptions](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-startOptions.md)参数。
2. 在[StartOptions](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-startOptions.md)参数中设置`windowMode`字段为`WINDOW_MODE_FLOATING`，表示启动的UIAbility将以悬浮窗的形式展示。
3. `windowMode`属性仅适用于系统应用，三方应用可以使用`displayId`属性。

示例中的context的获取方式请参见[获取UIAbility的上下文信息](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-usage.md#获取uiability的上下文信息)。

```ts
import AbilityConstant from '@ohos.app.ability.AbilityConstant';
import common from '@ohos.app.ability.common';
import Want from '@ohos.app.ability.Want';
import StartOptions from '@ohos.app.ability.StartOptions';
import { BusinessError } from '@ohos.base';

let context: common.UIAbilityContext = ...; // UIAbilityContext
let want: Want = {
  deviceId: '', // deviceId为空表示本设备
  bundleName: 'com.example.myapplication',
  moduleName: 'func', // moduleName非必选
  abilityName: 'FuncAbility',
  parameters: { // 自定义信息
    info: '来自EntryAbility Index页面',
  },
}
let options: StartOptions = {
  windowMode: AbilityConstant.WindowMode.WINDOW_MODE_FLOATING
};
// context为调用方UIAbility的UIAbilityContext
context.startAbility(want, options).then(() => {
  console.info('Succeeded in starting ability.');
}).catch((err: BusinessError) => {
  console.error(`Failed to start ability. Code is ${err.code}, message is ${err.message}`);
})
```

效果示意如下图所示。
![img](./开发者文档——开发.assets/start-uiability-floating-window.png)

#### 启动UIAbility的指定页面

##### 概述

一个UIAbility可以对应多个页面，在不同的场景下启动该UIAbility时需要展示不同的页面，例如从一个UIAbility的页面中跳转到另外一个UIAbility时，希望启动目标UIAbility的指定页面。

UIAbility的启动分为两种情况：UIAbility冷启动和UIAbility热启动。

- UIAbility冷启动：指的是UIAbility实例处于完全关闭状态下被启动，这需要完整地加载和初始化UIAbility实例的代码、资源等。
- UIAbility热启动：指的是UIAbility实例已经启动并在前台运行过，由于某些原因切换到后台，再次启动该UIAbility实例，这种情况下可以快速恢复UIAbility实例的状态。

本文主要讲解[目标UIAbility冷启动](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-intra-device-interaction.md#目标uiability冷启动)和[目标UIAbility热启动](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-intra-device-interaction.md#目标uiability热启动)两种启动指定页面的场景，以及在讲解启动指定页面之前会讲解到在调用方如何指定启动页面。

##### 调用方UIAbility指定启动页面

调用方UIAbility启动另外一个UIAbility时，通常需要跳转到指定的页面。例如FuncAbility包含两个页面（Index对应首页，Second对应功能A页面），此时需要在传入的want参数中配置指定的页面路径信息，可以通过want中的parameters参数增加一个自定义参数传递页面跳转信息。示例中的context的获取方式请参见[获取UIAbility的上下文信息](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-usage.md#获取uiability的上下文信息)。

```ts
import common from '@ohos.app.ability.common';
import Want from '@ohos.app.ability.Want';
import { BusinessError } from '@ohos.base';

let context: common.UIAbilityContext = ...; // UIAbilityContext
let want: Want = {
  deviceId: '', // deviceId为空表示本设备
  bundleName: 'com.example.funcapplication',
  moduleName: 'entry', // moduleName非必选
  abilityName: 'EntryAbility',
  parameters: { // 自定义参数传递页面信息
    router: 'funcA',
  },
}
// context为调用方UIAbility的UIAbilityContext
context.startAbility(want).then(() => {
  console.info('Succeeded in starting ability.');
}).catch((err: BusinessError) => {
  console.error(`Failed to start ability. Code is ${err.code}, message is ${err.message}`);
})
```

##### 目标UIAbility冷启动

目标UIAbility冷启动时，在目标UIAbility的`onCreate()`生命周期回调中，接收调用方传过来的参数。然后在目标UIAbility的`onWindowStageCreate()`生命周期回调中，解析EntryAbility传递过来的want参数，获取到需要加载的页面信息url，传入`windowStage.loadContent()`方法。

```ts
import AbilityConstant from '@ohos.app.ability.AbilityConstant';
import UIAbility from '@ohos.app.ability.UIAbility';
import Want from '@ohos.app.ability.Want';
import window from '@ohos.window';

export default class FuncAbility extends UIAbility {
  funcAbilityWant: Want | undefined = undefined;

  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
    // 接收调用方UIAbility传过来的参数
    this.funcAbilityWant = want;
  }

  onWindowStageCreate(windowStage: window.WindowStage) {
    // Main window is created, set main page for this ability
    let url = 'pages/Index';
    if (this.funcAbilityWant?.parameters?.router && this.funcAbilityWant.parameters.router === 'funcA') {
      url = 'pages/Second';
    }
    windowStage.loadContent(url, (err, data) => {
      // ...
    });
  }
}
```

##### 目标UIAbility热启动

在应用开发中，会遇到目标UIAbility实例之前已经启动过的场景，这时再次启动目标UIAbility时，不会重新走初始化逻辑，只会直接触发`onNewWant()`生命周期方法。为了实现跳转到指定页面，需要在`onNewWant()`中解析参数进行处理。

例如短信应用和联系人应用配合使用的场景。

1. 用户先打开短信应用，短信应用的UIAbility实例启动，显示短信应用的主页。
2. 用户将设备回到桌面界面，短信应用进入后台运行状态。
3. 用户打开联系人应用，找到联系人张三。
4. 用户点击联系人张三的短信按钮，会重新启动短信应用的UIAbility实例。
5. 由于短信应用的UIAbility实例已经启动过了，此时会触发该UIAbility的`onNewWant()`回调，而不会再走`onCreate()`和`onWindowStageCreate()`等初始化逻辑。

图1 目标UIAbility热启动
![img](./开发者文档——开发.assets/uiability-hot-start.png)

开发步骤如下所示。

1. 冷启动短信应用的UIAbility实例时，在`onWindowStageCreate()`生命周期回调中，通过调用[`getUIContext()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-window.md#getuicontext10)接口获取UI上下文实例[`UIContext`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-arkui-UIContext.md)对象。

   ```ts
   import AbilityConstant from '@ohos.app.ability.AbilityConstant';
   import UIAbility from '@ohos.app.ability.UIAbility';
   import Want from '@ohos.app.ability.Want';
   import window from '@ohos.window';
   
   import { UIContext } from '@ohos.arkui.UIContext';
   
   export default class EntryAbility extends UIAbility {
     funcAbilityWant: Want | undefined = undefined;
     uiContext: UIContext | undefined = undefined;
   
     // ...
   
     onWindowStageCreate(windowStage: window.WindowStage) {
       // Main window is created, set main page for this ability
       let url = 'pages/Index';
       if (this.funcAbilityWant?.parameters?.router && this.funcAbilityWant.parameters.router === 'funcA') {
         url = 'pages/Second';
       }
   
       windowStage.loadContent(url, (err, data) => {
         if (err.code) {
           return;
         }
   
         let windowClass: window.Window;
         windowStage.getMainWindow((err, data) => {
           if (err.code) {
             console.error(`Failed to obtain the main window. Code is ${err.code}, message is ${err.message}`);
             return;
           }
           windowClass = data;
           this.uiContext = windowClass.getUIContext();
         })
       });
     }
   }
   ```

2. 在短信应用UIAbility的`onNewWant()`回调中解析调用方传递过来的want参数，通过调用UIContext中的[`getRouter()`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-arkui-UIContext.md#getrouter)方法获取[`Router`](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-arkui-UIContext.md#router)对象，并进行指定页面的跳转。此时再次启动该短信应用的UIAbility实例时，即可跳转到该短信应用的UIAbility实例的指定页面。

   ```ts
   import AbilityConstant from '@ohos.app.ability.AbilityConstant';
   import UIAbility from '@ohos.app.ability.UIAbility';
   import Want from '@ohos.app.ability.Want';
   import { Router, UIContext } from '@ohos.arkui.UIContext';
   import { BusinessError } from '@ohos.base';
   
   export default class EntryAbility extends UIAbility {
     funcAbilityWant: Want | undefined = undefined;
     uiContext: UIContext | undefined = undefined;
   
     onNewWant(want: Want, launchParam: AbilityConstant.LaunchParam) {
       if (want?.parameters?.router && want.parameters.router === 'funcA') {
         let funcAUrl = 'pages/Second';
         if (this.uiContext) {
           let router: Router = this.uiContext.getRouter();
           router.pushUrl({
             url: funcAUrl
           }).catch((err: BusinessError) => {
             console.error(`Failed to push url. Code is ${err.code}, message is ${err.message}`);
           })
         }
       }
     }
   
     // ...
   }
   ```

> **说明：**
>
> 当被调用方[UIAbility组件启动模式](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-launch-type.md)设置为multiton启动模式时，每次启动都会创建一个新的实例，那么[onNewWant()](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#abilityonnewwant)回调就不会被用到。

#### 通过Call调用实现UIAbility交互（仅对系统应用开放）

Call调用是UIAbility能力的扩展，它为UIAbility提供一种能够被外部调用并与外部进行通信的能力。Call调用支持前台与后台两种启动方式，使UIAbility既能被拉起到前台展示UI，也可以在后台被创建并运行。Call调用在调用方与被调用方间建立了IPC通信，因此应用开发者可通过Call调用实现不同UIAbility之间的数据共享。

Call调用的核心接口是`startAbilityByCall()`方法，与`startAbility()`接口的不同之处在于：

- startAbilityByCall支持前台与后台两种启动方式，而`startAbility()`仅支持前台启动。
- 调用方可使用`startAbilityByCall()`所返回的Caller对象与被调用方进行通信，而`startAbility()`不具备通信能力。

Call调用的使用场景主要包括：

- 需要与被启动的UIAbility进行通信。
- 希望被启动的UIAbility在后台运行。

**表1** Call调用相关名词解释

| 名词          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| CallerAbility | 进行Call调用的UIAbility（调用方）。                          |
| CalleeAbility | 被Call调用的UIAbility（被调用方）。                          |
| Caller        | 实际对象，由startAbilityByCall接口返回，CallerAbility可使用Caller与CalleeAbility进行通信。 |
| Callee        | 实际对象，被CalleeAbility持有，可与Caller进行通信。          |

Call调用示意图如下所示。

**图1** Call调用示意图
![call](./开发者文档——开发.assets/call.png)

- CallerAbility调用startAbilityByCall接口获取Caller，并使用Caller对象的call方法向CalleeAbility发送数据。
- CalleeAbility持有一个Callee对象，通过Callee的on方法注册回调函数，当接收到Caller发送的数据时将会调用对应的回调函数。

> **说明：**
>
> 1. 当前仅支持系统应用使用Call调用。
> 2. CalleeAbility的启动模式需要为单实例。
> 3. Call调用既支持本地（设备内）Call调用，也支持跨设备Call调用，下面介绍设备内Call调用方法。跨设备Call调用方法请参见[跨设备Call调用](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/hop-multi-device-collaboration.md#通过跨设备call调用实现多端协同)。

##### 接口说明

Call功能主要接口如下表所示。具体的API详见[接口文档](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-app-ability-uiAbility.md#caller)。

**表2** Call功能主要接口

| 接口名                                                       | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| startAbilityByCall(want: Want): Promise<Caller>              | 启动指定UIAbility并获取其Caller通信接口，默认为后台启动，通过配置want可实现前台启动，详见[接口文档](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/reference/apis/js-apis-inner-application-uiAbilityContext.md#abilitycontextstartabilitybycall)。AbilityContext与ServiceExtensionContext均支持该接口。 |
| on(method: string, callback: CalleeCallBack): void           | 通用组件Callee注册method对应的callback方法。                 |
| off(method: string): void                                    | 通用组件Callee解注册method的callback方法。                   |
| call(method: string, data: rpc.Parcelable): Promise<void>    | 向通用组件Callee发送约定序列化数据。                         |
| callWithResult(method: string, data: rpc.Parcelable): Promise<rpc.MessageSequence> | 向通用组件Callee发送约定序列化数据, 并将Callee返回的约定序列化数据带回。 |
| release(): void                                              | 释放通用组件的Caller通信接口。                               |
| on(type: “release”, callback: OnReleaseCallback): void       | 注册通用组件通信断开监听通知。                               |

设备内通过Call调用实现UIAbility交互，涉及如下两部分开发：

- [创建Callee被调用端](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-intra-device-interaction.md#开发步骤创建callee被调用端)
- [访问Callee被调用端](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-intra-device-interaction.md#开发步骤访问callee被调用端)

##### 开发步骤（创建Callee被调用端）

在Callee被调用端，需要实现指定方法的数据接收回调函数、数据的序列化及反序列化方法。在需要接收数据期间，通过on接口注册监听，无需接收数据时通过off接口解除监听。

1. 配置UIAbility的启动模式。

   例如将CalleeAbility配置为单实例模式`singleton`，配置方式请参见[UIAbility组件启动模式](https://docs.openharmony.cn/pages/v4.0/zh-cn/application-dev/application-models/uiability-launch-type.md)。

2. 导入UIAbility模块。

   ```
   import UIAbility from '@ohos.app.ability.UIAbility';
   ts
   ```

3. 定义约定的序列化数据。 调用端及被调用端发送接收的数据格式需协商一致，如下示例约定数据由number和string组成。

   ```ts
   import rpc from '@ohos.rpc';
   
   export default class MyParcelable {
     num: number = 0;
     str: string = '';
   
     constructor(num: number, string: string) {
       this.num = num;
       this.str = string;
     }
   
     marshalling(messageSequence: rpc.MessageSequence) {
       messageSequence.writeInt(this.num);
       messageSequence.writeString(this.str);
       return true;
     }
   
     unmarshalling(messageSequence: rpc.MessageSequence) {
       this.num = messageSequence.readInt();
       this.str = messageSequence.readString();
       return true;
     }
   }
   ts
   ```

4. 实现Callee.on监听及Callee.off解除监听。

   被调用端Callee的监听函数注册时机，取决于应用开发者。注册监听之前的数据不会被处理，取消监听之后的数据不会被处理。如下示例在UIAbility的onCreate注册’MSG_SEND_METHOD’监听，在onDestroy取消监听，收到序列化数据后作相应处理并返回，应用开发者根据实际需要做相应处理。具体示例代码如下：

   ```ts
   import AbilityConstant from '@ohos.app.ability.AbilityConstant';
   import UIAbility from '@ohos.app.ability.UIAbility';
   import Want from '@ohos.app.ability.Want';
   import rpc from '@ohos.rpc';
   import { BusinessError } from '@ohos.base';
   import MyParcelable from './MyParcelable';
   
   const MSG_SEND_METHOD: string = 'CallSendMsg';
   
   function sendMsgCallback(data: rpc.MessageSequence) {
     console.info('CalleeSortFunc called');
   
     // 获取Caller发送的序列化数据
     let receivedData: MyParcelable = new MyParcelable(0, '');
     data.readParcelable(receivedData);
     console.info(`receiveData[${receivedData.num}, ${receivedData.str}]`);
     let num: number = receivedData.num;
   
     // 作相应处理
     // 返回序列化数据result给Caller
     return new MyParcelable(num + 1, `send ${receivedData.str} succeed`) as rpc.Parcelable;
   }
   
   export default class CalleeAbility extends UIAbility {
     onCreate(want: Want, launchParam: AbilityConstant.LaunchParam) {
       try {
         this.callee.on(MSG_SEND_METHOD, sendMsgCallback);
       } catch (err) {
         let code = (err as BusinessError).code;
         let message = (err as BusinessError).message;
         console.error(`Failed to register. Code is ${code}, message is ${message}`);
       }
     }
   
     onDestroy() {
       try {
         this.callee.off(MSG_SEND_METHOD);
       } catch (err) {
         let code = (err as BusinessError).code;
         let message = (err as BusinessError).message;
         console.error(`Failed to unregister. Code is ${code}, message is ${message}`);
       }
     }
   }
   ts
   ```

##### 开发步骤（访问Callee被调用端）

1. 导入UIAbility模块。

   ```
   import UIAbility from '@ohos.app.ability.UIAbility';
   ts
   ```

2. 获取Caller通信接口。 UIAbilityContext属性实现了startAbilityByCall方法，用于获取指定通用组件的Caller通信接口。如下示例通过this.context获取UIAbility实例的context属性，使用startAbilityByCall拉起Callee被调用端并获取Caller通信接口，注册Caller的onRelease监听。应用开发者根据实际需要做相应处理。

   ```ts
   import UIAbility from '@ohos.app.ability.UIAbility';
   import { Caller } from '@ohos.app.ability.UIAbility';
   import { BusinessError } from '@ohos.base';
   
   export default class CallerAbility extends UIAbility {
     caller: Caller | undefined = undefined;
   
     // 注册caller的release监听
     private regOnRelease(caller: Caller) {
       try {
         caller.on('release', (msg: string) => {
           console.info(`caller onRelease is called ${msg}`);
         })
         console.info('Succeeded in registering on release.');
       } catch (err) {
         let code = (err as BusinessError).code;
         let message = (err as BusinessError).message;
         console.error(`Failed to caller register on release. Code is ${code}, message is ${message}`);
       }
     }
   
     async onButtonGetCaller() {
       try {
         this.caller = await this.context.startAbilityByCall({
           bundleName: 'com.samples.CallApplication',
           abilityName: 'CalleeAbility'
         });
         if (this.caller === undefined) {
           console.info('get caller failed')
           return;
         }
         console.info('get caller success')
         this.regOnRelease(this.caller)
       } catch (err) {
         let code = (err as BusinessError).code;
         let message = (err as BusinessError).message;
         console.error(`Failed to get caller. Code is ${code}, message is ${message}`);
       }
     }
   }
   ts
   ```

#### 相关实例

针对UIAbility组件间交互开发，有以下相关实例可供参考：

- [UIAbility内和UIAbility间页面的跳转（ArkTS）（API9）](https://gitee.com/openharmony/codelabs/tree/master/Ability/StageAbility)
- [UIAbility内页面间的跳转（ArkTS）（API9）](https://gitee.com/openharmony/codelabs/tree/master/Ability/PagesRouter)

